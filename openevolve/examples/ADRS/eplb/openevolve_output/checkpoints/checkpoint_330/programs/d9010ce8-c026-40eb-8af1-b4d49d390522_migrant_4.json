{"id": "d9010ce8-c026-40eb-8af1-b4d49d390522_migrant_4", "code": "# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\non how the EPLB algorithm works.\n\"\"\"\n\n# EVOLVE-BLOCK-START\n\nimport torch\n\n\ndef balanced_packing(weight: torch.Tensor,\n                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Pack n weighted objects to m packs, such that each bin contains exactly\n    n/m objects and the weights of all packs are as balanced as possible.\n\n    Parameters:\n        weight: [X, n], the weight of each item\n        num_packs: number of packs\n\n    Returns:\n        pack_index: [X, n], the pack index of each item\n        rank_in_pack: [X, n], the rank of the item in the pack\n    \"\"\"\n    num_layers, num_groups = weight.shape\n    assert num_groups % num_packs == 0\n    groups_per_pack = num_groups // num_packs\n\n    if groups_per_pack == 1:\n        # If each group is its own pack, no complex packing needed.\n        # Create results directly on the original device.\n        pack_index = torch.arange(weight.size(-1),\n                                  dtype=torch.int64,\n                                  device=weight.device).expand(weight.shape)\n        rank_in_pack = torch.zeros_like(weight, dtype=torch.int64)\n        return pack_index, rank_in_pack\n\n    original_device = weight.device\n    # Sort indices on CPU for the Python loop, as Python lists are used for pack_weights and pack_items.\n    # The weight tensor itself can remain on its original device.\n    indices = weight.float().sort(-1, descending=True).indices.cpu()\n\n    # Create tensors for results on CPU, then move them to the original_device at the end.\n    pack_index_cpu = torch.full_like(weight,\n                                     fill_value=-1,\n                                     dtype=torch.int64,\n                                     device=\"cpu\")\n    rank_in_pack_cpu = torch.full_like(pack_index_cpu, fill_value=-1)\n\n    for i in range(num_layers):\n        # Use float for pack_weights to avoid potential issues with large integer sums\n        # and for consistency with the input `weight` being float.\n        pack_weights = [0.0] * num_packs\n        pack_items = [0] * num_packs\n        for group in indices[i]:\n            # Find the pack with the minimum current weight that still has capacity.\n            pack = min(\n                (j for j in range(num_packs) if pack_items[j] < groups_per_pack),\n                key=pack_weights.__getitem__,\n            )\n            assert pack_items[pack] < groups_per_pack\n            pack_index_cpu[i, group] = pack\n            rank_in_pack_cpu[i, group] = pack_items[pack]\n            # Convert scalar tensor to Python float for addition to Python list.\n            pack_weights[pack] += weight[i, group].item()\n            pack_items[pack] += 1\n    return pack_index_cpu.to(original_device), rank_in_pack_cpu.to(original_device)\n\n\ndef replicate_experts(\n        weight: torch.Tensor,\n        num_phy: int) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Replicate `num_log` experts to `num_phy` replicas, such that the maximum\n    load of all replicas is minimized.\n\n    Parameters:\n        weight: [X, num_log]\n        num_phy: total number of experts after replication\n\n    Returns:\n        phy2log: [X, num_phy], logical expert id of each physical expert\n        rank: [X, num_phy], the replica rank\n        logcnt: [X, num_log], number of replicas for each logical expert\n    \"\"\"\n    n, num_log = weight.shape\n    num_redundant = num_phy - num_log\n    assert num_redundant >= 0\n    device = weight.device\n\n    # Initialize `phy2log` and `rank` for the initial `num_log` experts.\n    # These are the non-replicated experts, mapping physical 0..num_log-1 to logical 0..num_log-1\n    # with replica rank 0.\n    initial_phy2log = torch.arange(num_log, dtype=torch.int64, device=device).repeat(n, 1)\n    initial_rank = torch.zeros(n, num_log, dtype=torch.int64, device=device)\n    logcnt = torch.ones(n, num_log, dtype=torch.int64, device=device)\n    arangen = torch.arange(n, dtype=torch.int64, device=device)\n\n    # Pre-allocate `phy2log` and `rank` to the final `num_phy` size.\n    final_phy2log = torch.empty(n, num_phy, dtype=torch.int64, device=device)\n    final_rank = torch.empty(n, num_phy, dtype=torch.int64, device=device)\n\n    # Copy initial expert mappings\n    final_phy2log[:, :num_log] = initial_phy2log\n    final_rank[:, :num_log] = initial_rank\n\n    # Replicate experts by adding `num_redundant` physical experts.\n    # These new experts are appended starting from index `num_log`.\n    for i in range(num_log, num_phy):\n        # Find the logical expert that currently has the highest average load per replica.\n        redundant_indices = (weight / logcnt).max(dim=-1).indices\n        # Assign this logical expert to the current physical expert slot `i`.\n        final_phy2log[:, i] = redundant_indices\n        # The rank of this new replica is its current count for that logical expert.\n        final_rank[:, i] = logcnt[arangen, redundant_indices]\n        # Increment the count of replicas for the chosen logical expert.\n        logcnt[arangen, redundant_indices] += 1\n    return final_phy2log, final_rank, logcnt\n\n\ndef rebalance_experts_hierarchical(\n    weight: torch.Tensor,\n    num_physical_experts: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n):\n    \"\"\"\n    Parameters:\n        weight: [num_moe_layers, num_logical_experts]\n        num_physical_experts: number of physical experts after replication\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n        (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [num_moe_layers, num_physical_experts]\n        logical_to_physical_map: [num_moe_layers, num_logical_experts, X]\n        logical_count: [num_moe_layers, num_logical_experts]\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    assert num_logical_experts % num_groups == 0\n    group_size = num_logical_experts // num_groups\n    assert num_groups % num_nodes == 0\n    groups_per_node = num_groups // num_nodes\n    assert num_gpus % num_nodes == 0\n    assert num_physical_experts % num_gpus == 0\n    phy_experts_per_gpu = num_physical_experts // num_gpus\n\n    def inverse(perm: torch.Tensor) -> torch.Tensor:\n        inv = torch.empty_like(perm)\n        inv.scatter_(\n            1,\n            perm,\n            torch.arange(perm.size(1), dtype=torch.int64,\n                         device=perm.device).expand(perm.shape),\n        )\n        return inv\n\n    # Step 1: pack groups to nodes\n    tokens_per_group = weight.unflatten(-1, (num_groups, group_size)).sum(-1)\n    group_pack_index, group_rank_in_pack = balanced_packing(\n        tokens_per_group, num_nodes)\n    log2mlog = (((group_pack_index * groups_per_node + group_rank_in_pack) *\n                 group_size).unsqueeze(-1) +\n                torch.arange(group_size,\n                             dtype=torch.int64,\n                             device=group_pack_index.device)).flatten(-2)\n    mlog2log = inverse(log2mlog)\n\n    # Step 2: construct redundant experts within nodes\n    # [num_layers * num_nodes, num_logical_experts // num_nodes]\n    tokens_per_mlog = weight.gather(-1, mlog2log).view(\n        -1, num_logical_experts // num_nodes)\n    phy2mlog, phyrank, mlogcnt = replicate_experts(\n        tokens_per_mlog, num_physical_experts // num_nodes)\n\n    # Step 3: pack physical_experts to GPUs\n    # [num_layers * num_nodes, num_physical_experts // num_nodes]\n    tokens_per_phy = (tokens_per_mlog / mlogcnt).gather(-1, phy2mlog)\n    pack_index, rank_in_pack = balanced_packing(tokens_per_phy,\n                                                num_gpus // num_nodes)\n    phy2pphy = pack_index * phy_experts_per_gpu + rank_in_pack\n    pphy2phy = inverse(phy2pphy)\n\n    pphy2mlog = phy2mlog.gather(\n        -1, pphy2phy)  # [num_layers * num_nodes, num_log_per_nodes]\n    pphy2mlog = (pphy2mlog.view(num_layers, num_nodes, -1) + torch.arange(\n        0,\n        num_logical_experts,\n        num_logical_experts // num_nodes,\n        device=group_pack_index.device,\n    ).view(1, -1, 1)).flatten(-2)\n    pphy2log = mlog2log.gather(-1, pphy2mlog)\n    pphyrank = phyrank.gather(-1, pphy2phy).view(num_layers, -1)\n    logcnt = mlogcnt.view(num_layers, -1).gather(-1, log2mlog)\n    return pphy2log, pphyrank, logcnt\n\n\ndef rebalance_experts(\n    weight: torch.Tensor,\n    num_replicas: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Entry point for expert-parallelism load balancer.\n\n    Parameters:\n        weight: [layers, num_logical_experts], the load statistics for all\n            logical experts\n        num_replicas: number of physical experts, must be a multiple of\n            `num_gpus`\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n            (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [layers, num_replicas], the expert index of\n            each replica\n        logical_to_physical_map: [layers, num_logical_experts, X], the replica\n            indices for each expert\n        expert_count: [layers, num_logical_experts], number of physical\n            replicas for each logical expert\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    # Ensure weight is float, but keep it on its original device.\n    # The .cpu() call is removed to allow GPU operations where possible,\n    # reducing device transfer overhead if `weight` originates from GPU.\n    weight = weight.float()\n    original_device = weight.device\n\n    if num_groups % num_nodes == 0:\n        # Use hierarchical load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, num_groups, num_nodes, num_gpus)\n    else:\n        # Use global load-balance policy when groups are not perfectly divisible by nodes.\n        # This simplifies the problem to a single \"node\" and \"group\" for global balancing.\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, 1, 1, num_gpus)\n\n    num_redundant_experts = num_replicas - num_logical_experts\n    # maxlogcnt determines the maximum number of replicas any single logical expert can have.\n    # This is used to size the `log2phy` tensor, which maps logical experts to their physical replicas.\n    maxlogcnt = num_redundant_experts + 1\n\n    # Initialize `log2phy` tensor with -1, indicating empty slots.\n    # This tensor maps [layer, logical_expert_id, replica_rank] to physical_expert_id.\n    log2phy: torch.Tensor = torch.full(\n        (num_layers, num_logical_experts, maxlogcnt),\n        -1,\n        dtype=torch.int64,\n        device=original_device,\n    )\n\n    # Populate `log2phy` using scatter_ based on `phy2log` and `phyrank`.\n    # `phy2log` gives the logical ID for each physical expert.\n    # `phyrank` gives the replica rank for that logical ID.\n    # We flatten the last two dimensions of `log2phy` for scatter_ operation.\n    # The index for scatter_ is calculated as `logical_id * maxlogcnt + replica_rank`.\n    # The values to scatter are the physical expert IDs (0 to num_replicas-1).\n    log2phy.view(num_layers, -1).scatter_(\n        -1,\n        phy2log * maxlogcnt + phyrank,\n        torch.arange(num_replicas, dtype=torch.int64,\n                     device=original_device).expand(num_layers, -1),\n    )\n    return phy2log, log2phy, logcnt\n\n\n# EVOLVE-BLOCK-END\n\n__all__ = [\"rebalance_experts\"]\n\n", "language": "python", "parent_id": "d9010ce8-c026-40eb-8af1-b4d49d390522", "generation": 1, "timestamp": 1751063252.6209333, "iteration_found": 0, "metrics": {"balancedness_score": 0.29830835153138974, "speed_score": 0.040541223449130276, "combined_score": 0.16942478749026002}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 79 lines with 108 lines\nChange 2: Replace 24 lines with 43 lines", "parent_metrics": {"balancedness_score": 0.29830835153138974, "speed_score": 0.03499673741440451, "combined_score": 0.16665254447289712}, "island": 4, "migrant": true}, "artifacts_json": null, "artifact_dir": null}