{"id": "d5017d21-4241-4feb-91a4-ca5a3ff78384", "code": "# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\non how the EPLB algorithm works.\n\"\"\"\n\n# EVOLVE-BLOCK-START\n\nimport torch\n\n\ndef balanced_packing(weight: torch.Tensor,\n                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Pack n weighted objects to m packs, such that each bin contains exactly\n    n/m objects and the weights of all packs are as balanced as possible.\n\n    Parameters:\n        weight: [X, n], the weight of each item\n        num_packs: number of packs\n\n    Returns:\n        pack_index: [X, n], the pack index of each item\n        rank_in_pack: [X, n], the rank of the item in the pack\n    \"\"\"\n    num_layers, num_groups = weight.shape\n    assert num_groups % num_packs == 0\n    groups_per_pack = num_groups // num_packs\n\n    if groups_per_pack == 1:\n        pack_index = torch.arange(weight.size(-1),\n                                  dtype=torch.int64,\n                                  device=weight.device).expand(weight.shape)\n        rank_in_pack = torch.zeros_like(weight, dtype=torch.int64)\n        return pack_index, rank_in_pack\n\n    # Sort groups by weight in descending order.\n    # 'weight' is already float and on CPU from rebalance_experts,\n    # so no need for .float().cpu() here.\n    sorted_weights, indices = weight.sort(-1, descending=True)\n\n    # Initialize pack_index and rank_in_pack.\n    # These will be fully populated, so `empty_like` is sufficient.\n    # They will be on the same device as 'weight' (i.e., CPU).\n    pack_index = torch.empty_like(weight, dtype=torch.int64)\n    rank_in_pack = torch.empty_like(pack_index)\n    \n    # Iterate over each layer. The greedy assignment per layer is sequential.\n    for i in range(num_layers):\n        # Min-heap for the current layer's packs.\n        # Elements are (current_total_weight, pack_id)\n        pack_heap = [(0.0, p_idx) for p_idx in range(num_packs)]\n        heapq.heapify(pack_heap)\n\n        # Keep track of how many items are in each pack for the current layer\n        current_pack_items = torch.zeros(num_packs, dtype=torch.int64, device=weight.device)\n\n        # For each layer, process groups in sorted order of their weights.\n        # indices[i] gives the original group IDs in descending weight order.\n        # sorted_weights[i] gives the actual weights in descending order.\n        for k in range(num_groups): # Iterate num_groups times through sorted items\n            original_group_id = indices[i, k].item() # Original index of the group\n            group_weight = sorted_weights[i, k].item() # Weight of this group\n\n            # Get the pack with the minimum current total weight.\n            min_weight, pack_id = heapq.heappop(pack_heap)\n\n            # Assert that the pack is not yet full. This should be guaranteed by the logic.\n            assert current_pack_items[pack_id] < groups_per_pack, \\\n                f\"Pack {pack_id} for layer {i} is full but still in heap.\"\n\n            # Assign the group to the chosen pack.\n            pack_index[i, original_group_id] = pack_id\n            rank_in_pack[i, original_group_id] = current_pack_items[pack_id]\n\n            # Update item count for this pack.\n            current_pack_items[pack_id] += 1\n            \n            # If the pack is not yet full, push it back with updated weight.\n            if current_pack_items[pack_id] < groups_per_pack:\n                new_weight = min_weight + group_weight\n                heapq.heappush(pack_heap, (new_weight, pack_id))\n            # Else, this pack is now full and won't be re-added to the heap.\n            # This implicitly handles the \"full_mask\" logic from the original code.\n            \n    return pack_index, rank_in_pack\n\n\nimport heapq\n\ndef replicate_experts(\n        weight: torch.Tensor,\n        num_phy: int) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Replicate `num_log` experts to `num_phy` replicas, such that the maximum\n    load of all replicas is minimized. Optimized using a min-heap.\n\n    Parameters:\n        weight: [X, num_log]  (e.g., [num_layers * num_nodes, num_logical_experts_per_node])\n        num_phy: total number of experts after replication (e.g., num_physical_experts_per_node)\n\n    Returns:\n        phy2log: [X, num_phy], logical expert id of each physical expert\n        rank: [X, num_phy], the replica rank (0-indexed)\n        logcnt: [X, num_log], number of replicas for each logical expert\n    \"\"\"\n    n, num_log = weight.shape\n    num_redundant = num_phy - num_log\n    assert num_redundant >= 0\n    device = weight.device\n\n    # Initialize output tensors\n    # phy2log: maps physical expert index to logical expert index\n    # rank: maps physical expert index to its replica rank (0-indexed)\n    phy2log = torch.empty((n, num_phy), dtype=torch.int64, device=device)\n    rank = torch.empty((n, num_phy), dtype=torch.int64, device=device)\n    \n    # Keep track of the current number of replicas for each logical expert\n    # This is effectively the 'logcnt' output, but used internally for selection\n    current_logcnt = torch.ones(n, num_log, dtype=torch.int64, device=device)\n    \n    # Use arangen for efficient indexing into current_logcnt\n    arangen = torch.arange(n, dtype=torch.int64, device=device)\n\n    # Min-heap to store the best available replica score for each logical expert.\n    # Heap elements are tuples: (-score_tensor, logical_expert_index, replica_rank)\n    # We use negative score to simulate a max-heap.\n    # Calculate initial scores for all logical experts in a batched manner.\n    # The score represents the maximum load across 'n' contexts if this expert\n    # gets its first replica.\n    # scores: [num_log]\n    scores = (weight / 1.0).max(dim=0).values\n\n    min_heap = []\n    for j in range(num_log):\n        # Push (negative_score, logical_idx, rank) to simulate a max-heap\n        heapq.heappush(min_heap, (-scores[j].item(), j, 1))\n\n    # Fill the remaining physical experts by greedily picking the best available replica.\n    # We need to assign `num_phy` physical experts in total.\n    # We iterate `num_phy` times to assign all physical experts.\n    for i in range(num_phy): # Iterate from 0 to num_phy-1 for physical expert index\n        if not min_heap: # Should not happen if num_phy >= num_log\n            break\n\n        # Get the logical expert with the highest score (most negative in heap)\n        neg_score, best_log_idx, rank_val = heapq.heappop(min_heap)\n        \n        # Assign this physical expert to the chosen logical expert\n        phy2log[:, i] = best_log_idx\n        # The rank is 0-indexed\n        rank[:, i] = rank_val - 1 \n\n        # Update the count of replicas for this logical expert\n        # This `current_logcnt` will be the final `logcnt` output.\n        current_logcnt[arangen, best_log_idx] = rank_val\n        \n        # If this logical expert can still receive more replicas,\n        # push its next replica's score to the heap.\n        # The maximum number of replicas for any logical expert is implicitly num_phy.\n        # We add the next replica only if it's potentially useful.\n        if rank_val < num_phy: # Check if there's room for another replica\n            # Ensure float division for the next score calculation\n            # Ensure float division for the next score calculation\n            # Use .max().item() again for the scalar heap score\n            # Optimization: The initial 'scores' already hold the maximum weight\n            # for each logical expert across all contexts.\n            # (weight[:, best_log_idx] / (rank_val + 1.0)).max() is equivalent to\n            # (weight[:, best_log_idx].max() / (rank_val + 1.0)), which is\n            # (scores[best_log_idx] / (rank_val + 1.0)).\n            next_score = (scores[best_log_idx] / (rank_val + 1.0)).item()\n            heapq.heappush(min_heap, (-next_score, best_log_idx, rank_val + 1))\n\n    # The `current_logcnt` tensor now holds the number of replicas for each logical expert.\n    # This is the `logcnt` output.\n    return phy2log, rank, current_logcnt\n\n\ndef rebalance_experts_hierarchical(\n    weight: torch.Tensor,\n    num_physical_experts: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n):\n    \"\"\"\n    Parameters:\n        weight: [num_moe_layers, num_logical_experts]\n        num_physical_experts: number of physical experts after replication\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n        (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [num_moe_layers, num_physical_experts]\n        logical_to_physical_map: [num_moe_layers, num_logical_experts, X]\n        logical_count: [num_moe_layers, num_logical_experts]\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    assert num_logical_experts % num_groups == 0\n    group_size = num_logical_experts // num_groups\n    assert num_groups % num_nodes == 0\n    groups_per_node = num_groups // num_nodes\n    assert num_gpus % num_nodes == 0\n    assert num_physical_experts % num_gpus == 0\n    phy_experts_per_gpu = num_physical_experts // num_gpus\n\n    def inverse(perm: torch.Tensor) -> torch.Tensor:\n        inv = torch.empty_like(perm)\n        inv.scatter_(\n            1,\n            perm,\n            torch.arange(perm.size(1), dtype=torch.int64,\n                         device=perm.device).expand(perm.shape),\n        )\n        return inv\n\n    # Step 1: pack groups to nodes\n    tokens_per_group = weight.unflatten(-1, (num_groups, group_size)).sum(-1)\n    group_pack_index, group_rank_in_pack = balanced_packing(\n        tokens_per_group, num_nodes)\n    log2mlog = (((group_pack_index * groups_per_node + group_rank_in_pack) *\n                 group_size).unsqueeze(-1) +\n                torch.arange(group_size,\n                             dtype=torch.int64,\n                             device=group_pack_index.device)).flatten(-2)\n    mlog2log = inverse(log2mlog)\n\n    # Step 2: construct redundant experts within nodes\n    # [num_layers * num_nodes, num_logical_experts // num_nodes]\n    tokens_per_mlog = weight.gather(-1, mlog2log).view(\n        -1, num_logical_experts // num_nodes)\n    phy2mlog, phyrank, mlogcnt = replicate_experts(\n        tokens_per_mlog, num_physical_experts // num_nodes)\n\n    # Step 3: pack physical_experts to GPUs\n    # [num_layers * num_nodes, num_physical_experts // num_nodes]\n    tokens_per_phy = (tokens_per_mlog / mlogcnt).gather(-1, phy2mlog)\n    pack_index, rank_in_pack = balanced_packing(tokens_per_phy,\n                                                num_gpus // num_nodes)\n    phy2pphy = pack_index * phy_experts_per_gpu + rank_in_pack\n    pphy2phy = inverse(phy2pphy)\n\n    pphy2mlog = phy2mlog.gather(\n        -1, pphy2phy)  # [num_layers * num_nodes, num_log_per_nodes]\n    pphy2mlog = (pphy2mlog.view(num_layers, num_nodes, -1) + torch.arange(\n        0,\n        num_logical_experts,\n        num_logical_experts // num_nodes,\n        device=group_pack_index.device,\n    ).view(1, -1, 1)).flatten(-2)\n    pphy2log = mlog2log.gather(-1, pphy2mlog)\n    pphyrank = phyrank.gather(-1, pphy2phy).view(num_layers, -1)\n    logcnt = mlogcnt.view(num_layers, -1).gather(-1, log2mlog)\n    return pphy2log, pphyrank, logcnt\n\n\ndef rebalance_experts(\n    weight: torch.Tensor,\n    num_replicas: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Entry point for expert-parallelism load balancer.\n\n    Parameters:\n        weight: [layers, num_logical_experts], the load statistics for all\n            logical experts\n        num_replicas: number of physical experts, must be a multiple of\n            `num_gpus`\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n            (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [layers, num_replicas], the expert index of\n            each replica\n        logical_to_physical_map: [layers, num_logical_experts, X], the replica\n            indices for each expert\n        expert_count: [layers, num_logical_experts], number of physical\n            replicas for each logical expert\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    weight = weight.float().cpu()\n    if num_groups % num_nodes == 0:\n        # use hierarchical load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, num_groups, num_nodes, num_gpus)\n    else:\n        # use global load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, 1, 1, num_gpus)\n    # The maximum possible number of replicas for any single logical expert\n    # is the total number of physical replicas available.\n    maxlogcnt = num_replicas\n    log2phy: torch.Tensor = torch.full(\n        (num_layers, num_logical_experts, maxlogcnt),\n        -1,\n        dtype=torch.int64,\n        device=logcnt.device,\n    )\n    # The 'phyrank' can range up to num_physical_experts - 1 in worst-case (global policy).\n    # Using 'num_replicas' as maxlogcnt ensures sufficient space for scatter_ indexing.\n    log2phy.view(num_layers, -1).scatter_(\n        -1,\n        phy2log * maxlogcnt + phyrank,\n        torch.arange(num_replicas, dtype=torch.int64,\n                     device=log2phy.device).expand(num_layers, -1),\n    )\n    return phy2log, log2phy, logcnt\n\n\n# EVOLVE-BLOCK-END\n\n__all__ = [\"rebalance_experts\"]\n\n", "language": "python", "parent_id": "af940ffa-5481-4c08-a72b-722cafc225ac", "generation": 8, "timestamp": 1751060503.966307, "iteration_found": 167, "metrics": {"balancedness_score": 0.019312741718508577, "speed_score": 0.03496595877095736, "combined_score": 0.02713935024473297}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace next_score = (weight[:, best_log_idx] / (rank_val + 1.0)).max().item() with 6 lines", "parent_metrics": {"balancedness_score": 0.019312741718508577, "speed_score": 0.035177036668397645, "combined_score": 0.02724488919345311}, "island": 3}, "artifacts_json": null, "artifact_dir": null, "prompts": {"diff_user": {"system": "You are an expert programmer specializing in optimization algorithms. Your task is to improve the Mixture-of-Expert models Expert Parallelism Load Balancer (MoE EPLB) expert rearrangement algorithm.\nThis algorithm will take the load metrics recorded by the vLLM server, and rearrange the experts to balance the load. It can make replicas of some experts to achieve better load balancing.\nYour goal will be two-fold: 1. Improve the algorithm to achieve better load balancing; while 2. Improve the algorithm to be more efficient, i.e. reduce the execution time of the algorithm itself, since perfect load balancing is NP-hard.\nThe current algorithm is implemented in the `rebalance_experts` function. ", "user": "# Current Program Information\n- Current performance metrics: - balancedness_score: 0.0193\n- speed_score: 0.0352\n- combined_score: 0.0272\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: balancedness_score, speed_score, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: balancedness_score: 0.2983, speed_score: 0.0835, combined_score: 0.1909\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: balancedness_score: 0.2983, speed_score: 0.0845, combined_score: 0.1914\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: balancedness_score: 0.2983, speed_score: 0.0857, combined_score: 0.1920\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.1920)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\n# ... (truncated for brevity)\n```\nKey features: Performs well on balancedness_score (0.2983), Performs well on speed_score (0.0857), Performs well on combined_score (0.1920)\n\n\n### Program 2 (Score: 0.1914)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\n# ... (truncated for brevity)\n```\nKey features: Performs well on balancedness_score (0.2983), Performs well on speed_score (0.0845), Performs well on combined_score (0.1914)\n\n\n### Program 3 (Score: 0.1909)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\n# ... (truncated for brevity)\n```\nKey features: Performs well on balancedness_score (0.2983), Performs well on speed_score (0.0835), Performs well on combined_score (0.1909)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.1908)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n# ... (truncated)\n```\nKey features: Alternative approach to balancedness_score, Alternative approach to speed_score\n\n\n### Program D2 (Score: 0.1907)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n# ... (truncated)\n```\nKey features: Alternative approach to balancedness_score, Alternative approach to speed_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.1920, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Alternative balancedness_score approach, Alternative speed_score approach, Alternative combined_score approach\n\n\n### Inspiration 2 (Score: 0.0939, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Modification: Change 1: Replace 23 lines with 236 lines, Alternative balancedness_score approach, Alternative speed_score approach\n\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Modification: Change 1: Replace 19 lines with 14 lines\nChange 2: Replace 77 lines with 74 lines, Alternative balancedness_score approach, Alternative speed_score approach\n\n\n### Inspiration 4 (Score: 0.0275, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Modification: Change 1: Replace 50 lines with 50 lines, Alternative balancedness_score approach, Alternative speed_score approach\n\n\n### Inspiration 5 (Score: 0.1623, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Modification: Change 1: Replace 20 lines with 9 lines, Alternative balancedness_score approach, Alternative speed_score approach\n\n\n\n# Current Program\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\non how the EPLB algorithm works.\n\"\"\"\n\n# EVOLVE-BLOCK-START\n\nimport torch\n\n\ndef balanced_packing(weight: torch.Tensor,\n                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Pack n weighted objects to m packs, such that each bin contains exactly\n    n/m objects and the weights of all packs are as balanced as possible.\n\n    Parameters:\n        weight: [X, n], the weight of each item\n        num_packs: number of packs\n\n    Returns:\n        pack_index: [X, n], the pack index of each item\n        rank_in_pack: [X, n], the rank of the item in the pack\n    \"\"\"\n    num_layers, num_groups = weight.shape\n    assert num_groups % num_packs == 0\n    groups_per_pack = num_groups // num_packs\n\n    if groups_per_pack == 1:\n        pack_index = torch.arange(weight.size(-1),\n                                  dtype=torch.int64,\n                                  device=weight.device).expand(weight.shape)\n        rank_in_pack = torch.zeros_like(weight, dtype=torch.int64)\n        return pack_index, rank_in_pack\n\n    # Sort groups by weight in descending order.\n    # 'weight' is already float and on CPU from rebalance_experts,\n    # so no need for .float().cpu() here.\n    sorted_weights, indices = weight.sort(-1, descending=True)\n\n    # Initialize pack_index and rank_in_pack.\n    # These will be fully populated, so `empty_like` is sufficient.\n    # They will be on the same device as 'weight' (i.e., CPU).\n    pack_index = torch.empty_like(weight, dtype=torch.int64)\n    rank_in_pack = torch.empty_like(pack_index)\n    \n    # Iterate over each layer. The greedy assignment per layer is sequential.\n    for i in range(num_layers):\n        # Min-heap for the current layer's packs.\n        # Elements are (current_total_weight, pack_id)\n        pack_heap = [(0.0, p_idx) for p_idx in range(num_packs)]\n        heapq.heapify(pack_heap)\n\n        # Keep track of how many items are in each pack for the current layer\n        current_pack_items = torch.zeros(num_packs, dtype=torch.int64, device=weight.device)\n\n        # For each layer, process groups in sorted order of their weights.\n        # indices[i] gives the original group IDs in descending weight order.\n        # sorted_weights[i] gives the actual weights in descending order.\n        for k in range(num_groups): # Iterate num_groups times through sorted items\n            original_group_id = indices[i, k].item() # Original index of the group\n            group_weight = sorted_weights[i, k].item() # Weight of this group\n\n            # Get the pack with the minimum current total weight.\n            min_weight, pack_id = heapq.heappop(pack_heap)\n\n            # Assert that the pack is not yet full. This should be guaranteed by the logic.\n            assert current_pack_items[pack_id] < groups_per_pack, \\\n                f\"Pack {pack_id} for layer {i} is full but still in heap.\"\n\n            # Assign the group to the chosen pack.\n            pack_index[i, original_group_id] = pack_id\n            rank_in_pack[i, original_group_id] = current_pack_items[pack_id]\n\n            # Update item count for this pack.\n            current_pack_items[pack_id] += 1\n            \n            # If the pack is not yet full, push it back with updated weight.\n            if current_pack_items[pack_id] < groups_per_pack:\n                new_weight = min_weight + group_weight\n                heapq.heappush(pack_heap, (new_weight, pack_id))\n            # Else, this pack is now full and won't be re-added to the heap.\n            # This implicitly handles the \"full_mask\" logic from the original code.\n            \n    return pack_index, rank_in_pack\n\n\nimport heapq\n\ndef replicate_experts(\n        weight: torch.Tensor,\n        num_phy: int) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Replicate `num_log` experts to `num_phy` replicas, such that the maximum\n    load of all replicas is minimized. Optimized using a min-heap.\n\n    Parameters:\n        weight: [X, num_log]  (e.g., [num_layers * num_nodes, num_logical_experts_per_node])\n        num_phy: total number of experts after replication (e.g., num_physical_experts_per_node)\n\n    Returns:\n        phy2log: [X, num_phy], logical expert id of each physical expert\n        rank: [X, num_phy], the replica rank (0-indexed)\n        logcnt: [X, num_log], number of replicas for each logical expert\n    \"\"\"\n    n, num_log = weight.shape\n    num_redundant = num_phy - num_log\n    assert num_redundant >= 0\n    device = weight.device\n\n    # Initialize output tensors\n    # phy2log: maps physical expert index to logical expert index\n    # rank: maps physical expert index to its replica rank (0-indexed)\n    phy2log = torch.empty((n, num_phy), dtype=torch.int64, device=device)\n    rank = torch.empty((n, num_phy), dtype=torch.int64, device=device)\n    \n    # Keep track of the current number of replicas for each logical expert\n    # This is effectively the 'logcnt' output, but used internally for selection\n    current_logcnt = torch.ones(n, num_log, dtype=torch.int64, device=device)\n    \n    # Use arangen for efficient indexing into current_logcnt\n    arangen = torch.arange(n, dtype=torch.int64, device=device)\n\n    # Min-heap to store the best available replica score for each logical expert.\n    # Heap elements are tuples: (-score_tensor, logical_expert_index, replica_rank)\n    # We use negative score to simulate a max-heap.\n    # Calculate initial scores for all logical experts in a batched manner.\n    # The score represents the maximum load across 'n' contexts if this expert\n    # gets its first replica.\n    # scores: [num_log]\n    scores = (weight / 1.0).max(dim=0).values\n\n    min_heap = []\n    for j in range(num_log):\n        # Push (negative_score, logical_idx, rank) to simulate a max-heap\n        heapq.heappush(min_heap, (-scores[j].item(), j, 1))\n\n    # Fill the remaining physical experts by greedily picking the best available replica.\n    # We need to assign `num_phy` physical experts in total.\n    # We iterate `num_phy` times to assign all physical experts.\n    for i in range(num_phy): # Iterate from 0 to num_phy-1 for physical expert index\n        if not min_heap: # Should not happen if num_phy >= num_log\n            break\n\n        # Get the logical expert with the highest score (most negative in heap)\n        neg_score, best_log_idx, rank_val = heapq.heappop(min_heap)\n        \n        # Assign this physical expert to the chosen logical expert\n        phy2log[:, i] = best_log_idx\n        # The rank is 0-indexed\n        rank[:, i] = rank_val - 1 \n\n        # Update the count of replicas for this logical expert\n        # This `current_logcnt` will be the final `logcnt` output.\n        current_logcnt[arangen, best_log_idx] = rank_val\n        \n        # If this logical expert can still receive more replicas,\n        # push its next replica's score to the heap.\n        # The maximum number of replicas for any logical expert is implicitly num_phy.\n        # We add the next replica only if it's potentially useful.\n        if rank_val < num_phy: # Check if there's room for another replica\n            # Ensure float division for the next score calculation\n            # Ensure float division for the next score calculation\n            # Use .max().item() again for the scalar heap score\n            next_score = (weight[:, best_log_idx] / (rank_val + 1.0)).max().item()\n            heapq.heappush(min_heap, (-next_score, best_log_idx, rank_val + 1))\n\n    # The `current_logcnt` tensor now holds the number of replicas for each logical expert.\n    # This is the `logcnt` output.\n    return phy2log, rank, current_logcnt\n\n\ndef rebalance_experts_hierarchical(\n    weight: torch.Tensor,\n    num_physical_experts: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n):\n    \"\"\"\n    Parameters:\n        weight: [num_moe_layers, num_logical_experts]\n        num_physical_experts: number of physical experts after replication\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n        (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [num_moe_layers, num_physical_experts]\n        logical_to_physical_map: [num_moe_layers, num_logical_experts, X]\n        logical_count: [num_moe_layers, num_logical_experts]\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    assert num_logical_experts % num_groups == 0\n    group_size = num_logical_experts // num_groups\n    assert num_groups % num_nodes == 0\n    groups_per_node = num_groups // num_nodes\n    assert num_gpus % num_nodes == 0\n    assert num_physical_experts % num_gpus == 0\n    phy_experts_per_gpu = num_physical_experts // num_gpus\n\n    def inverse(perm: torch.Tensor) -> torch.Tensor:\n        inv = torch.empty_like(perm)\n        inv.scatter_(\n            1,\n            perm,\n            torch.arange(perm.size(1), dtype=torch.int64,\n                         device=perm.device).expand(perm.shape),\n        )\n        return inv\n\n    # Step 1: pack groups to nodes\n    tokens_per_group = weight.unflatten(-1, (num_groups, group_size)).sum(-1)\n    group_pack_index, group_rank_in_pack = balanced_packing(\n        tokens_per_group, num_nodes)\n    log2mlog = (((group_pack_index * groups_per_node + group_rank_in_pack) *\n                 group_size).unsqueeze(-1) +\n                torch.arange(group_size,\n                             dtype=torch.int64,\n                             device=group_pack_index.device)).flatten(-2)\n    mlog2log = inverse(log2mlog)\n\n    # Step 2: construct redundant experts within nodes\n    # [num_layers * num_nodes, num_logical_experts // num_nodes]\n    tokens_per_mlog = weight.gather(-1, mlog2log).view(\n        -1, num_logical_experts // num_nodes)\n    phy2mlog, phyrank, mlogcnt = replicate_experts(\n        tokens_per_mlog, num_physical_experts // num_nodes)\n\n    # Step 3: pack physical_experts to GPUs\n    # [num_layers * num_nodes, num_physical_experts // num_nodes]\n    tokens_per_phy = (tokens_per_mlog / mlogcnt).gather(-1, phy2mlog)\n    pack_index, rank_in_pack = balanced_packing(tokens_per_phy,\n                                                num_gpus // num_nodes)\n    phy2pphy = pack_index * phy_experts_per_gpu + rank_in_pack\n    pphy2phy = inverse(phy2pphy)\n\n    pphy2mlog = phy2mlog.gather(\n        -1, pphy2phy)  # [num_layers * num_nodes, num_log_per_nodes]\n    pphy2mlog = (pphy2mlog.view(num_layers, num_nodes, -1) + torch.arange(\n        0,\n        num_logical_experts,\n        num_logical_experts // num_nodes,\n        device=group_pack_index.device,\n    ).view(1, -1, 1)).flatten(-2)\n    pphy2log = mlog2log.gather(-1, pphy2mlog)\n    pphyrank = phyrank.gather(-1, pphy2phy).view(num_layers, -1)\n    logcnt = mlogcnt.view(num_layers, -1).gather(-1, log2mlog)\n    return pphy2log, pphyrank, logcnt\n\n\ndef rebalance_experts(\n    weight: torch.Tensor,\n    num_replicas: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Entry point for expert-parallelism load balancer.\n\n    Parameters:\n        weight: [layers, num_logical_experts], the load statistics for all\n            logical experts\n        num_replicas: number of physical experts, must be a multiple of\n            `num_gpus`\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n            (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [layers, num_replicas], the expert index of\n            each replica\n        logical_to_physical_map: [layers, num_logical_experts, X], the replica\n            indices for each expert\n        expert_count: [layers, num_logical_experts], number of physical\n            replicas for each logical expert\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    weight = weight.float().cpu()\n    if num_groups % num_nodes == 0:\n        # use hierarchical load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, num_groups, num_nodes, num_gpus)\n    else:\n        # use global load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, 1, 1, num_gpus)\n    # The maximum possible number of replicas for any single logical expert\n    # is the total number of physical replicas available.\n    maxlogcnt = num_replicas\n    log2phy: torch.Tensor = torch.full(\n        (num_layers, num_logical_experts, maxlogcnt),\n        -1,\n        dtype=torch.int64,\n        device=logcnt.device,\n    )\n    # The 'phyrank' can range up to num_physical_experts - 1 in worst-case (global policy).\n    # Using 'num_replicas' as maxlogcnt ensures sufficient space for scatter_ indexing.\n    log2phy.view(num_layers, -1).scatter_(\n        -1,\n        phy2log * maxlogcnt + phyrank,\n        torch.arange(num_replicas, dtype=torch.int64,\n                     device=log2phy.device).expand(num_layers, -1),\n    )\n    return phy2log, log2phy, logcnt\n\n\n# EVOLVE-BLOCK-END\n\n__all__ = [\"rebalance_experts\"]\n\n\n```\n\n# Task\nSuggest improvements to the program that will lead to better performance on the specified metrics.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n", "responses": ["The current program's performance is significantly lower than previous attempts, especially in `balancedness_score` and `speed_score`. This suggests a potential regression or a highly inefficient part in the current implementation.\n\nUpon analyzing the code, the most significant performance bottleneck is identified within the `replicate_experts` function. Specifically, the line `next_score = (weight[:, best_log_idx] / (rank_val + 1.0)).max().item()` is executed `num_phy` times within a loop. The `weight[:, best_log_idx].max()` operation involves iterating over `n` elements (where `n` can be `num_layers * num_nodes`, potentially a large number) for each of these `num_phy` iterations. This leads to a time complexity of `O(num_phy * n)` for this part, which is very inefficient.\n\nThe `scores` tensor, initialized at the beginning of `replicate_experts` as `(weight / 1.0).max(dim=0).values`, already stores `max_k(weight[k, j])` for each logical expert `j`. Mathematically, `max(A / C)` where `C` is a positive scalar is equivalent to `max(A) / C`. Therefore, `(weight[:, best_log_idx] / (rank_val + 1.0)).max()` is equivalent to `(weight[:, best_log_idx].max() / (rank_val + 1.0))`, which is simply `(scores[best_log_idx] / (rank_val + 1.0))`.\n\nBy replacing the inefficient `weight[:, best_log_idx].max().item()` with the pre-computed `scores[best_log_idx].item()`, we can drastically reduce the complexity of `replicate_experts` from `O(num_phy * (log num_log + n))` to `O(num_log * n + num_phy * log num_log)`. The `num_log * n` term comes from the initial `weight.max(dim=0)` which is performed once, and the `num_phy * log num_log` term comes from the heap operations. This change maintains the correctness and balancing effectiveness of the algorithm while significantly improving its speed.\n\n**Proposed Change:**\n\nReplace the inefficient calculation of `next_score` in `replicate_experts` with an equivalent, optimized version that leverages the already computed `scores` tensor.\n\n<<<<<<< SEARCH\n            next_score = (weight[:, best_log_idx] / (rank_val + 1.0)).max().item()\n=======\n            # Optimization: The initial 'scores' already hold the maximum weight\n            # for each logical expert across all contexts.\n            # (weight[:, best_log_idx] / (rank_val + 1.0)).max() is equivalent to\n            # (weight[:, best_log_idx].max() / (rank_val + 1.0)), which is\n            # (scores[best_log_idx] / (rank_val + 1.0)).\n            next_score = (scores[best_log_idx] / (rank_val + 1.0)).item()\n>>>>>>> REPLACE"]}}}