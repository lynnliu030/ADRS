{"id": "6616669a-7cd4-4c7c-b289-d78736f8c8fd", "code": "# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\non how the EPLB algorithm works.\n\"\"\"\n\n# EVOLVE-BLOCK-START\n\nimport torch\n\n\ndef balanced_packing(weight: torch.Tensor,\n                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Pack n weighted objects to m packs, such that each bin contains exactly\n    n/m objects and the weights of all packs are as balanced as possible.\n\n    This implementation vectorizes the greedy assignment across layers for improved efficiency.\n\n    Parameters:\n        weight: [X, n], the weight of each item (X is num_layers or num_layers * num_nodes)\n        num_packs: number of packs\n\n    Returns:\n        pack_index: [X, n], the pack index of each item\n        rank_in_pack: [X, n], the rank of the item in the pack\n    \"\"\"\n    num_layers, num_groups = weight.shape\n    # Calculate capacities for each pack.\n    # Some packs will hold `base_items_per_pack + 1` items, others `base_items_per_pack`.\n    base_items_per_pack = num_groups // num_packs\n    extra_item_packs = num_groups % num_packs\n\n    # Determine capacity for each pack index.\n    # Packs 0 to (extra_item_packs - 1) get base_items_per_pack + 1.\n    # Remaining packs get base_items_per_pack.\n    # This tensor will be [num_packs] and broadcasted across layers.\n    pack_capacities = torch.full((num_packs,), base_items_per_pack, dtype=torch.int64, device=weight.device)\n    if extra_item_packs > 0:\n        pack_capacities[:extra_item_packs] += 1\n\n    # Sort groups by weight in descending order for all layers.\n    indices = weight.sort(-1, descending=True).indices  # [num_layers, num_groups]\n\n    # Initialize output tensors.\n    pack_index = torch.empty_like(weight, dtype=torch.int64)\n    rank_in_pack = torch.empty_like(pack_index)\n    \n    # Initialize tensors to hold current pack weights and item counts for all layers.\n    pack_weights_per_layer = torch.zeros(\n        num_layers, num_packs, dtype=weight.dtype, device=weight.device)\n    pack_items_per_layer = torch.zeros(\n        num_layers, num_packs, dtype=torch.int64, device=weight.device)\n\n    # Precompute layer indices for vectorized operations.\n    layer_indices = torch.arange(num_layers, device=weight.device)\n\n    # Iterate over sorted group ranks (k) for all layers simultaneously.\n    # In each iteration, we assign the k-th heaviest group (for each layer)\n    # to the least loaded pack (for that layer).\n    for k in range(num_groups):\n        # group_ids_to_assign: [num_layers] - the actual group_id for each layer at rank k\n        group_ids_to_assign = indices[:, k] \n        \n        # weights_to_assign: [num_layers] - the weight of these groups\n        weights_to_assign = weight[layer_indices, group_ids_to_assign]\n\n        # Find the pack with the minimum current weight for each layer.\n        # Mask full packs by setting their weights to infinity.\n        # pack_capacities needs to be unsqueezed to (1, num_packs) to broadcast correctly.\n        is_pack_full = (pack_items_per_layer == pack_capacities.unsqueeze(0))\n        \n        current_pack_weights_masked = torch.where(\n            is_pack_full,\n            float('inf'),  # Set full packs to infinity\n            pack_weights_per_layer\n        )\n        \n        # chosen_packs: [num_layers] - the chosen pack index for each layer\n        chosen_packs = torch.argmin(current_pack_weights_masked, dim=1)\n\n        # Assign the group to the chosen pack for each layer.\n        pack_index[layer_indices, group_ids_to_assign] = chosen_packs\n        rank_in_pack[layer_indices, group_ids_to_assign] = \\\n            pack_items_per_layer[layer_indices, chosen_packs]\n\n        # Update pack weights and item counts for the chosen packs across layers.\n        pack_weights_per_layer[layer_indices, chosen_packs] += weights_to_assign\n        pack_items_per_layer[layer_indices, chosen_packs] += 1\n    \n    return pack_index, rank_in_pack\n\n\ndef replicate_experts(\n        weight: torch.Tensor,\n        num_phy: int) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Replicate `num_log` experts to `num_phy` replicas, such that the maximum\n    load of all replicas is minimized.\n\n    Parameters:\n        weight: [X, num_log]\n        num_phy: total number of experts after replication\n\n    Returns:\n        phy2log: [X, num_phy], logical expert id of each physical expert\n        rank: [X, num_phy], the replica rank\n        logcnt: [X, num_log], number of replicas for each logical expert\n    \"\"\"\n    n, num_log = weight.shape\n    num_redundant = num_phy - num_log\n    assert num_redundant >= 0\n    device = weight.device\n    phy2log = torch.arange(num_phy, dtype=torch.int64,\n                           device=device).repeat(n, 1)\n    rank = torch.zeros(n, num_phy, dtype=torch.int64, device=device)\n    logcnt = torch.ones(n, num_log, dtype=torch.int64, device=device)\n    arangen = torch.arange(n, dtype=torch.int64, device=device)\n    \n    # This loop runs `num_redundant` times. In each iteration, it performs\n    # division and a reduction (max) over `num_log` elements for `n` layers.\n    # This can be a bottleneck if `num_redundant`, `n`, or `num_log` are large.\n    # The greedy nature of the algorithm (replicating the currently most\n    # overloaded expert) generally requires these sequential updates.\n    for i in range(num_log, num_phy):\n        redundant_indices = (weight / logcnt).max(dim=-1).indices\n        phy2log[:, i] = redundant_indices\n        rank[:, i] = logcnt[arangen, redundant_indices]\n        logcnt[arangen, redundant_indices] += 1\n    return phy2log, rank, logcnt\n\n\ndef rebalance_experts_hierarchical(\n    weight: torch.Tensor,\n    num_physical_experts: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n):\n    \"\"\"\n    Parameters:\n        weight: [num_moe_layers, num_logical_experts]\n        num_physical_experts: number of physical experts after replication\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n        (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [num_moe_layers, num_physical_experts]\n        logical_to_physical_map: [num_moe_layers, num_logical_experts, X]\n        logical_count: [num_moe_layers, num_logical_experts]\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    # These asserts define the structural assumptions of the hierarchical setup,\n    # ensuring consistent sizing for groups, nodes, and GPUs.\n    assert num_logical_experts % num_groups == 0\n    group_size = num_logical_experts // num_groups\n    assert num_groups % num_nodes == 0\n    groups_per_node = num_groups // num_nodes\n    assert num_gpus % num_nodes == 0\n    assert num_physical_experts % num_gpus == 0\n    phy_experts_per_gpu = num_physical_experts // num_gpus\n\n    def inverse(perm: torch.Tensor) -> torch.Tensor:\n        inv = torch.empty_like(perm)\n        inv.scatter_(\n            1,\n            perm,\n            torch.arange(perm.size(1), dtype=torch.int64,\n                         device=perm.device).expand(perm.shape),\n        )\n        return inv\n\n    # Step 1: pack groups to nodes\n    tokens_per_group = weight.unflatten(-1, (num_groups, group_size)).sum(-1)\n    group_pack_index, group_rank_in_pack = balanced_packing(\n        tokens_per_group, num_nodes)\n    log2mlog = (((group_pack_index * groups_per_node + group_rank_in_pack) *\n                 group_size).unsqueeze(-1) +\n                torch.arange(group_size,\n                             dtype=torch.int64,\n                             device=group_pack_index.device)).flatten(-2)\n    mlog2log = inverse(log2mlog)\n\n    # Step 2: construct redundant experts within nodes\n    # [num_layers * num_nodes, num_logical_experts // num_nodes]\n    tokens_per_mlog = weight.gather(-1, mlog2log).view(\n        -1, num_logical_experts // num_nodes)\n    phy2mlog, phyrank, mlogcnt = replicate_experts(\n        tokens_per_mlog, num_physical_experts // num_nodes)\n\n    # Step 3: pack physical_experts to GPUs\n    # [num_layers * num_nodes, num_physical_experts // num_nodes]\n    tokens_per_phy = (tokens_per_mlog / mlogcnt).gather(-1, phy2mlog)\n    pack_index, rank_in_pack = balanced_packing(tokens_per_phy,\n                                                num_gpus // num_nodes)\n    phy2pphy = pack_index * phy_experts_per_gpu + rank_in_pack\n    pphy2phy = inverse(phy2pphy)\n\n    pphy2mlog = phy2mlog.gather(\n        -1, pphy2phy)  # [num_layers * num_nodes, num_log_per_nodes]\n    pphy2mlog = (pphy2mlog.view(num_layers, num_nodes, -1) + torch.arange(\n        0,\n        num_logical_experts,\n        num_logical_experts // num_nodes,\n        device=group_pack_index.device,\n    ).view(1, -1, 1)).flatten(-2)\n    pphy2log = mlog2log.gather(-1, pphy2mlog)\n    pphyrank = phyrank.gather(-1, pphy2phy).view(num_layers, -1)\n    logcnt = mlogcnt.view(num_layers, -1).gather(-1, log2mlog)\n    return pphy2log, pphyrank, logcnt\n\n\ndef rebalance_experts(\n    weight: torch.Tensor,\n    num_replicas: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Entry point for expert-parallelism load balancer.\n\n    Parameters:\n        weight: [layers, num_logical_experts], the load statistics for all\n            logical experts\n        num_replicas: number of physical experts, must be a multiple of\n            `num_gpus`\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n            (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [layers, num_replicas], the expert index of\n            each replica\n        logical_to_physical_map: [layers, num_logical_experts, X], the replica\n            indices for each expert\n        expert_count: [layers, num_logical_experts], number of physical\n            replicas for each logical expert\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    # Ensure weight is float and on CPU, avoiding redundant conversions\n    # Ensure weight is float type and keep it on its original device (CPU or GPU).\n    # Explicitly moving to CPU is removed to allow GPU execution if weight is already on GPU.\n    # Ensure weight is float type and keep it on its original device (CPU or GPU).\n    if weight.dtype != torch.float:\n        weight = weight.float()\n    \n    # The hierarchical policy requires specific divisibility conditions for its\n    # structural mappings (e.g., experts per group, groups per node).\n    # If these conditions are not met, a 'global' balancing policy is used\n    # by treating all experts as one group on one node.\n    if num_groups % num_nodes == 0:\n        # use hierarchical load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, num_groups, num_nodes, num_gpus)\n    else:\n        # use global load-balance policy\n        # This path is taken when the strict divisibility for hierarchical\n        # grouping (num_groups % num_nodes == 0) is not met.\n        # It simplifies the problem to a single group on a single 'node'\n        # before replicating and packing to GPUs.\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, 1, 1, num_gpus)\n    num_redundant_experts = num_replicas - num_logical_experts\n    maxlogcnt = num_redundant_experts + 1\n    log2phy: torch.Tensor = torch.full(\n        (num_layers, num_logical_experts, maxlogcnt),\n        -1,\n        dtype=torch.int64,\n        device=logcnt.device,\n    )\n    log2phy.view(num_layers, -1).scatter_(\n        -1,\n        phy2log * maxlogcnt + phyrank,\n        torch.arange(num_replicas, dtype=torch.int64,\n                     device=log2phy.device).expand(num_layers, -1),\n    )\n    return phy2log, log2phy, logcnt\n\n\n# EVOLVE-BLOCK-END\n\n__all__ = [\"rebalance_experts\"]\n\n", "language": "python", "parent_id": "41403187-56f3-45b3-9d1f-e23aac4dd253", "generation": 8, "timestamp": 1751067941.5421474, "iteration_found": 283, "metrics": {"balancedness_score": 0.29830835153138974, "speed_score": 0.0830509417605696, "combined_score": 0.19067964664597967}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 59 lines with 63 lines\nChange 2: Replace 7 lines with 13 lines\nChange 3: Replace 8 lines with 10 lines\nChange 4: Replace 12 lines with 21 lines", "parent_metrics": {"balancedness_score": 0.29830835153138974, "speed_score": 0.08063224730172112, "combined_score": 0.18947029941655544}, "island": 4}, "artifacts_json": null, "artifact_dir": null, "prompts": {"diff_user": {"system": "You are an expert programmer specializing in optimization algorithms. Your task is to improve the Mixture-of-Expert models Expert Parallelism Load Balancer (MoE EPLB) expert rearrangement algorithm.\nThis algorithm will take the load metrics recorded by the vLLM server, and rearrange the experts to balance the load. It can make replicas of some experts to achieve better load balancing.\nYour goal will be two-fold: 1. Improve the algorithm to achieve better load balancing; while 2. Improve the algorithm to be more efficient, i.e. reduce the execution time of the algorithm itself, since perfect load balancing is NP-hard.\nThe current algorithm is implemented in the `rebalance_experts` function. ", "user": "# Current Program Information\n- Current performance metrics: - balancedness_score: 0.2983\n- speed_score: 0.0806\n- combined_score: 0.1895\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: balancedness_score, speed_score, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: balancedness_score: 0.3528, speed_score: 0.1125, combined_score: 0.2326\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: balancedness_score: 0.3528, speed_score: 0.1126, combined_score: 0.2327\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: balancedness_score: 0.3528, speed_score: 0.1143, combined_score: 0.2335\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.2335)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\n# ... (truncated for brevity)\n```\nKey features: Performs well on balancedness_score (0.3528), Performs well on speed_score (0.1143), Performs well on combined_score (0.2335)\n\n\n### Program 2 (Score: 0.2327)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\n# ... (truncated for brevity)\n```\nKey features: Performs well on balancedness_score (0.3528), Performs well on speed_score (0.1126), Performs well on combined_score (0.2327)\n\n\n### Program 3 (Score: 0.2326)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\n# ... (truncated for brevity)\n```\nKey features: Performs well on balancedness_score (0.3528), Performs well on speed_score (0.1125), Performs well on combined_score (0.2326)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.2325)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n# ... (truncated)\n```\nKey features: Alternative approach to balancedness_score, Alternative approach to speed_score\n\n\n### Program D2 (Score: 0.2322)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n# ... (truncated)\n```\nKey features: Alternative approach to balancedness_score, Alternative approach to speed_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.2335, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Modification: Change 1: Replace 32 lines with 17 lines, Alternative speed_score approach, Alternative combined_score approach\n\n\n### Inspiration 2 (Score: 0.0939, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Modification: Change 1: Replace 23 lines with 236 lines, Alternative balancedness_score approach, Alternative speed_score approach\n\n\n### Inspiration 3 (Score: 0.2312, Type: Migrant)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Alternative speed_score approach, Alternative combined_score approach, Comprehensive implementation\n\n\n### Inspiration 4 (Score: 0.0153, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Alternative balancedness_score approach, Alternative speed_score approach, Alternative combined_score approach\n\n\n### Inspiration 5 (Score: 0.1888, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Alternative balancedness_score approach, Alternative speed_score approach, Alternative combined_score approach\n\n\n\n# Current Program\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\non how the EPLB algorithm works.\n\"\"\"\n\n# EVOLVE-BLOCK-START\n\nimport torch\n\n\ndef balanced_packing(weight: torch.Tensor,\n                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Pack n weighted objects to m packs, such that each bin contains exactly\n    n/m objects and the weights of all packs are as balanced as possible.\n\n    This implementation vectorizes the greedy assignment across layers for improved efficiency.\n\n    Parameters:\n        weight: [X, n], the weight of each item (X is num_layers or num_layers * num_nodes)\n        num_packs: number of packs\n\n    Returns:\n        pack_index: [X, n], the pack index of each item\n        rank_in_pack: [X, n], the rank of the item in the pack\n    \"\"\"\n    num_layers, num_groups = weight.shape\n    assert num_groups % num_packs == 0\n    groups_per_pack = num_groups // num_packs\n\n    if groups_per_pack == 1:\n        # If each group is a pack, assignment is straightforward.\n        pack_index = torch.arange(num_groups,\n                                  dtype=torch.int64,\n                                  device=weight.device).expand(num_layers, -1)\n        rank_in_pack = torch.zeros_like(weight, dtype=torch.int64)\n        return pack_index, rank_in_pack\n\n    # Sort groups by weight in descending order for all layers.\n    # 'weight' is already float and on CPU from rebalance_experts.\n    indices = weight.sort(-1, descending=True).indices  # [num_layers, num_groups]\n\n    # Initialize output tensors.\n    pack_index = torch.empty_like(weight, dtype=torch.int64)\n    rank_in_pack = torch.empty_like(pack_index)\n    \n    # Initialize tensors to hold current pack weights and item counts for all layers.\n    pack_weights_per_layer = torch.zeros(\n        num_layers, num_packs, dtype=weight.dtype, device=weight.device)\n    pack_items_per_layer = torch.zeros(\n        num_layers, num_packs, dtype=torch.int64, device=weight.device)\n\n    # Precompute layer indices for vectorized operations.\n    layer_indices = torch.arange(num_layers, device=weight.device)\n\n    # Iterate over sorted group ranks (k) for all layers simultaneously.\n    # In each iteration, we assign the k-th heaviest group (for each layer)\n    # to the least loaded pack (for that layer).\n    for k in range(num_groups):\n        # group_ids_to_assign: [num_layers] - the actual group_id for each layer at rank k\n        group_ids_to_assign = indices[:, k] \n        \n        # weights_to_assign: [num_layers] - the weight of these groups\n        weights_to_assign = weight[layer_indices, group_ids_to_assign]\n\n        # Find the pack with the minimum current weight for each layer.\n        # Mask full packs by setting their weights to infinity.\n        current_pack_weights_masked = torch.where(\n            pack_items_per_layer == groups_per_pack,\n            float('inf'),  # Set full packs to infinity\n            pack_weights_per_layer\n        )\n        \n        # chosen_packs: [num_layers] - the chosen pack index for each layer\n        chosen_packs = torch.argmin(current_pack_weights_masked, dim=1)\n\n        # Assign the group to the chosen pack for each layer.\n        pack_index[layer_indices, group_ids_to_assign] = chosen_packs\n        rank_in_pack[layer_indices, group_ids_to_assign] = \\\n            pack_items_per_layer[layer_indices, chosen_packs]\n\n        # Update pack weights and item counts for the chosen packs across layers.\n        pack_weights_per_layer[layer_indices, chosen_packs] += weights_to_assign\n        pack_items_per_layer[layer_indices, chosen_packs] += 1\n    \n    return pack_index, rank_in_pack\n\n\ndef replicate_experts(\n        weight: torch.Tensor,\n        num_phy: int) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Replicate `num_log` experts to `num_phy` replicas, such that the maximum\n    load of all replicas is minimized.\n\n    Parameters:\n        weight: [X, num_log]\n        num_phy: total number of experts after replication\n\n    Returns:\n        phy2log: [X, num_phy], logical expert id of each physical expert\n        rank: [X, num_phy], the replica rank\n        logcnt: [X, num_log], number of replicas for each logical expert\n    \"\"\"\n    n, num_log = weight.shape\n    num_redundant = num_phy - num_log\n    assert num_redundant >= 0\n    device = weight.device\n    phy2log = torch.arange(num_phy, dtype=torch.int64,\n                           device=device).repeat(n, 1)\n    rank = torch.zeros(n, num_phy, dtype=torch.int64, device=device)\n    logcnt = torch.ones(n, num_log, dtype=torch.int64, device=device)\n    arangen = torch.arange(n, dtype=torch.int64, device=device)\n    for i in range(num_log, num_phy):\n        redundant_indices = (weight / logcnt).max(dim=-1).indices\n        phy2log[:, i] = redundant_indices\n        rank[:, i] = logcnt[arangen, redundant_indices]\n        logcnt[arangen, redundant_indices] += 1\n    return phy2log, rank, logcnt\n\n\ndef rebalance_experts_hierarchical(\n    weight: torch.Tensor,\n    num_physical_experts: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n):\n    \"\"\"\n    Parameters:\n        weight: [num_moe_layers, num_logical_experts]\n        num_physical_experts: number of physical experts after replication\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n        (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [num_moe_layers, num_physical_experts]\n        logical_to_physical_map: [num_moe_layers, num_logical_experts, X]\n        logical_count: [num_moe_layers, num_logical_experts]\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    assert num_logical_experts % num_groups == 0\n    group_size = num_logical_experts // num_groups\n    assert num_groups % num_nodes == 0\n    groups_per_node = num_groups // num_nodes\n    assert num_gpus % num_nodes == 0\n    assert num_physical_experts % num_gpus == 0\n    phy_experts_per_gpu = num_physical_experts // num_gpus\n\n    def inverse(perm: torch.Tensor) -> torch.Tensor:\n        inv = torch.empty_like(perm)\n        inv.scatter_(\n            1,\n            perm,\n            torch.arange(perm.size(1), dtype=torch.int64,\n                         device=perm.device).expand(perm.shape),\n        )\n        return inv\n\n    # Step 1: pack groups to nodes\n    tokens_per_group = weight.unflatten(-1, (num_groups, group_size)).sum(-1)\n    group_pack_index, group_rank_in_pack = balanced_packing(\n        tokens_per_group, num_nodes)\n    log2mlog = (((group_pack_index * groups_per_node + group_rank_in_pack) *\n                 group_size).unsqueeze(-1) +\n                torch.arange(group_size,\n                             dtype=torch.int64,\n                             device=group_pack_index.device)).flatten(-2)\n    mlog2log = inverse(log2mlog)\n\n    # Step 2: construct redundant experts within nodes\n    # [num_layers * num_nodes, num_logical_experts // num_nodes]\n    tokens_per_mlog = weight.gather(-1, mlog2log).view(\n        -1, num_logical_experts // num_nodes)\n    phy2mlog, phyrank, mlogcnt = replicate_experts(\n        tokens_per_mlog, num_physical_experts // num_nodes)\n\n    # Step 3: pack physical_experts to GPUs\n    # [num_layers * num_nodes, num_physical_experts // num_nodes]\n    tokens_per_phy = (tokens_per_mlog / mlogcnt).gather(-1, phy2mlog)\n    pack_index, rank_in_pack = balanced_packing(tokens_per_phy,\n                                                num_gpus // num_nodes)\n    phy2pphy = pack_index * phy_experts_per_gpu + rank_in_pack\n    pphy2phy = inverse(phy2pphy)\n\n    pphy2mlog = phy2mlog.gather(\n        -1, pphy2phy)  # [num_layers * num_nodes, num_log_per_nodes]\n    pphy2mlog = (pphy2mlog.view(num_layers, num_nodes, -1) + torch.arange(\n        0,\n        num_logical_experts,\n        num_logical_experts // num_nodes,\n        device=group_pack_index.device,\n    ).view(1, -1, 1)).flatten(-2)\n    pphy2log = mlog2log.gather(-1, pphy2mlog)\n    pphyrank = phyrank.gather(-1, pphy2phy).view(num_layers, -1)\n    logcnt = mlogcnt.view(num_layers, -1).gather(-1, log2mlog)\n    return pphy2log, pphyrank, logcnt\n\n\ndef rebalance_experts(\n    weight: torch.Tensor,\n    num_replicas: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Entry point for expert-parallelism load balancer.\n\n    Parameters:\n        weight: [layers, num_logical_experts], the load statistics for all\n            logical experts\n        num_replicas: number of physical experts, must be a multiple of\n            `num_gpus`\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n            (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [layers, num_replicas], the expert index of\n            each replica\n        logical_to_physical_map: [layers, num_logical_experts, X], the replica\n            indices for each expert\n        expert_count: [layers, num_logical_experts], number of physical\n            replicas for each logical expert\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    # Ensure weight is float and on CPU, avoiding redundant conversions\n    # Ensure weight is float type and keep it on its original device (CPU or GPU).\n    # Explicitly moving to CPU is removed to allow GPU execution if weight is already on GPU.\n    if weight.dtype != torch.float:\n        weight = weight.float()\n    \n    if num_groups % num_nodes == 0:\n        # use hierarchical load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, num_groups, num_nodes, num_gpus)\n    else:\n        # use global load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, 1, 1, num_gpus)\n    num_redundant_experts = num_replicas - num_logical_experts\n    maxlogcnt = num_redundant_experts + 1\n    log2phy: torch.Tensor = torch.full(\n        (num_layers, num_logical_experts, maxlogcnt),\n        -1,\n        dtype=torch.int64,\n        device=logcnt.device,\n    )\n    log2phy.view(num_layers, -1).scatter_(\n        -1,\n        phy2log * maxlogcnt + phyrank,\n        torch.arange(num_replicas, dtype=torch.int64,\n                     device=log2phy.device).expand(num_layers, -1),\n    )\n    return phy2log, log2phy, logcnt\n\n\n# EVOLVE-BLOCK-END\n\n__all__ = [\"rebalance_experts\"]\n\n\n```\n\n# Task\nSuggest improvements to the program that will lead to better performance on the specified metrics.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n", "responses": ["The current program shows a regression in `balancedness_score`, `speed_score`, and `combined_score` compared to previous top-performing versions. The goal is to improve both balancedness and efficiency.\n\nThe core algorithms, `balanced_packing` (for bin packing) and `replicate_experts` (for expert replication), employ standard greedy heuristics (Longest Processing Time for packing, highest average load for replication). These heuristics are generally effective but not optimal (as the problem is NP-hard).\n\n**Analysis of current code and potential for improvement:**\n\n1.  **`balanced_packing` function:**\n    *   The original `balanced_packing` had a special fast path for `groups_per_pack == 1` (i.e., when `num_groups == num_packs`).\n    *   It also asserted `num_groups % num_packs == 0`, meaning it only supported scenarios where items could be perfectly divided among packs.\n    *   In the `rebalance_experts_hierarchical` function, calls to `balanced_packing` are always made with arguments that satisfy `num_items % num_packs == 0` due to other structural assertions in `rebalance_experts_hierarchical`. Therefore, the current `balanced_packing`'s divisibility assertion is never violated when called from `rebalance_experts_hierarchical`.\n    *   **Improvement:** Generalize `balanced_packing` to handle cases where `num_groups % num_packs != 0`. This makes the function more robust and self-contained. By calculating `pack_capacities` (some packs get `floor(N/M)` items, others `ceil(N/M)`), the special `if groups_per_pack == 1:` case becomes redundant and can be removed, simplifying the code. This directly addresses the prompt's suggestion to \"simplify the code to improve readability and maintainability\". While this change won't alter the `balancedness_score` in the current setup (because `rebalance_experts_hierarchical`'s structural asserts prevent non-divisible calls), it cleans up the core utility function. The impact on `speed_score` is expected to be negligible or slightly positive due to reduced branching.\n\n2.  **`replicate_experts` function:**\n    *   This function iteratively selects the expert with the highest average load (`weight / logcnt`) for replication. This is a greedy approach and inherently sequential for optimal greedy choice.\n    *   The loop runs `num_redundant = num_phy - num_log` times. Inside the loop, `(weight / logcnt).max(dim=-1).indices` involves a division and reduction operation over `num_layers * num_log` elements. If `num_redundant`, `num_layers`, or `num_log` are large, this loop can be a significant bottleneck for `speed_score`.\n    *   **Improvement:** No algorithmic change is proposed here as the greedy nature requires sequential updates for correctness. However, adding a comment to highlight this computational bottleneck and its underlying reason (greedy, sequential updates) improves code readability and understanding for future optimization efforts.\n\n3.  **`rebalance_experts_hierarchical` and `rebalance_experts` functions:**\n    *   The `rebalance_experts_hierarchical` function has several `assert` statements that enforce strict divisibility for structural elements (e.g., `num_groups % num_nodes == 0`). These are necessary for its current indexing and reshaping logic to work correctly, defining how experts are grouped and mapped hierarchically.\n    *   The `rebalance_experts` function uses an `if/else` block to switch between the hierarchical policy (if `num_groups % num_nodes == 0`) and a \"global\" policy (by calling `rebalance_experts_hierarchical` with `num_groups=1, num_nodes=1`).\n    *   The `balancedness_score` regression might be partly due to this fallback to a \"global\" policy when the hierarchical conditions are not met, as a more nuanced hierarchical approach might be beneficial even in non-perfectly divisible scenarios. However, modifying this would require a significant re-architecture of `rebalance_experts_hierarchical` to handle non-uniform group/node sizes, which is out of scope for incremental changes and could introduce complexity or new bugs.\n    *   **Improvement:** Add comments to clarify the purpose of the structural asserts and the rationale for the hierarchical vs. global policy selection, aiding readability.\n\n**Proposed Changes (in diff format):**\n\nThe changes primarily focus on simplifying `balanced_packing` and improving code clarity through comments.\n\n1.  **Generalize and simplify `balanced_packing`:** Remove the special case for `groups_per_pack == 1` and implement `pack_capacities` to handle non-divisible scenarios, which also implicitly covers the perfect division case.\n\n2.  **Add explanatory comments:** Enhance readability by explaining performance bottlenecks and design choices.\n\n```diff\n<<<<<<< SEARCH\n    assert num_groups % num_packs == 0\n    groups_per_pack = num_groups // num_packs\n\n    if groups_per_pack == 1:\n        # If each group is a pack, assignment is straightforward.\n        pack_index = torch.arange(num_groups,\n                                  dtype=torch.int64,\n                                  device=weight.device).expand(num_layers, -1)\n        rank_in_pack = torch.zeros_like(weight, dtype=torch.int64)\n        return pack_index, rank_in_pack\n\n    # Sort groups by weight in descending order for all layers.\n    # 'weight' is already float and on CPU from rebalance_experts.\n    indices = weight.sort(-1, descending=True).indices  # [num_layers, num_groups]\n\n    # Initialize output tensors.\n    pack_index = torch.empty_like(weight, dtype=torch.int64)\n    rank_in_pack = torch.empty_like(pack_index)\n    \n    # Initialize tensors to hold current pack weights and item counts for all layers.\n    pack_weights_per_layer = torch.zeros(\n        num_layers, num_packs, dtype=weight.dtype, device=weight.device)\n    pack_items_per_layer = torch.zeros(\n        num_layers, num_packs, dtype=torch.int64, device=weight.device)\n\n    # Precompute layer indices for vectorized operations.\n    layer_indices = torch.arange(num_layers, device=weight.device)\n\n    # Iterate over sorted group ranks (k) for all layers simultaneously.\n    # In each iteration, we assign the k-th heaviest group (for each layer)\n    # to the least loaded pack (for that layer).\n    for k in range(num_groups):\n        # group_ids_to_assign: [num_layers] - the actual group_id for each layer at rank k\n        group_ids_to_assign = indices[:, k] \n        \n        # weights_to_assign: [num_layers] - the weight of these groups\n        weights_to_assign = weight[layer_indices, group_ids_to_assign]\n\n        # Find the pack with the minimum current weight for each layer.\n        # Mask full packs by setting their weights to infinity.\n        current_pack_weights_masked = torch.where(\n            pack_items_per_layer == groups_per_pack,\n            float('inf'),  # Set full packs to infinity\n            pack_weights_per_layer\n        )\n        \n        # chosen_packs: [num_layers] - the chosen pack index for each layer\n        chosen_packs = torch.argmin(current_pack_weights_masked, dim=1)\n\n        # Assign the group to the chosen pack for each layer.\n        pack_index[layer_indices, group_ids_to_assign] = chosen_packs\n        rank_in_pack[layer_indices, group_ids_to_assign] = \\\n            pack_items_per_layer[layer_indices, chosen_packs]\n\n        # Update pack weights and item counts for the chosen packs across layers.\n        pack_weights_per_layer[layer_indices, chosen_packs] += weights_to_assign\n        pack_items_per_layer[layer_indices, chosen_packs] += 1\n    \n    return pack_index, rank_in_pack\n=======\n    # Calculate capacities for each pack.\n    # Some packs will hold `base_items_per_pack + 1` items, others `base_items_per_pack`.\n    base_items_per_pack = num_groups // num_packs\n    extra_item_packs = num_groups % num_packs\n\n    # Determine capacity for each pack index.\n    # Packs 0 to (extra_item_packs - 1) get base_items_per_pack + 1.\n    # Remaining packs get base_items_per_pack.\n    # This tensor will be [num_packs] and broadcasted across layers.\n    pack_capacities = torch.full((num_packs,), base_items_per_pack, dtype=torch.int64, device=weight.device)\n    if extra_item_packs > 0:\n        pack_capacities[:extra_item_packs] += 1\n\n    # Sort groups by weight in descending order for all layers.\n    indices = weight.sort(-1, descending=True).indices  # [num_layers, num_groups]\n\n    # Initialize output tensors.\n    pack_index = torch.empty_like(weight, dtype=torch.int64)\n    rank_in_pack = torch.empty_like(pack_index)\n    \n    # Initialize tensors to hold current pack weights and item counts for all layers.\n    pack_weights_per_layer = torch.zeros(\n        num_layers, num_packs, dtype=weight.dtype, device=weight.device)\n    pack_items_per_layer = torch.zeros(\n        num_layers, num_packs, dtype=torch.int64, device=weight.device)\n\n    # Precompute layer indices for vectorized operations.\n    layer_indices = torch.arange(num_layers, device=weight.device)\n\n    # Iterate over sorted group ranks (k) for all layers simultaneously.\n    # In each iteration, we assign the k-th heaviest group (for each layer)\n    # to the least loaded pack (for that layer).\n    for k in range(num_groups):\n        # group_ids_to_assign: [num_layers] - the actual group_id for each layer at rank k\n        group_ids_to_assign = indices[:, k] \n        \n        # weights_to_assign: [num_layers] - the weight of these groups\n        weights_to_assign = weight[layer_indices, group_ids_to_assign]\n\n        # Find the pack with the minimum current weight for each layer.\n        # Mask full packs by setting their weights to infinity.\n        # pack_capacities needs to be unsqueezed to (1, num_packs) to broadcast correctly.\n        is_pack_full = (pack_items_per_layer == pack_capacities.unsqueeze(0))\n        \n        current_pack_weights_masked = torch.where(\n            is_pack_full,\n            float('inf'),  # Set full packs to infinity\n            pack_weights_per_layer\n        )\n        \n        # chosen_packs: [num_layers] - the chosen pack index for each layer\n        chosen_packs = torch.argmin(current_pack_weights_masked, dim=1)\n\n        # Assign the group to the chosen pack for each layer.\n        pack_index[layer_indices, group_ids_to_assign] = chosen_packs\n        rank_in_pack[layer_indices, group_ids_to_assign] = \\\n            pack_items_per_layer[layer_indices, chosen_packs]\n\n        # Update pack weights and item counts for the chosen packs across layers.\n        pack_weights_per_layer[layer_indices, chosen_packs] += weights_to_assign\n        pack_items_per_layer[layer_indices, chosen_packs] += 1\n    \n    return pack_index, rank_in_pack\n>>>>>>> REPLACE\n<<<<<<< SEARCH\n    arangen = torch.arange(n, dtype=torch.int64, device=device)\n    for i in range(num_log, num_phy):\n        redundant_indices = (weight / logcnt).max(dim=-1).indices\n        phy2log[:, i] = redundant_indices\n        rank[:, i] = logcnt[arangen, redundant_indices]\n        logcnt[arangen, redundant_indices] += 1\n    return phy2log, rank, logcnt\n=======\n    arangen = torch.arange(n, dtype=torch.int64, device=device)\n    \n    # This loop runs `num_redundant` times. In each iteration, it performs\n    # division and a reduction (max) over `num_log` elements for `n` layers.\n    # This can be a bottleneck if `num_redundant`, `n`, or `num_log` are large.\n    # The greedy nature of the algorithm (replicating the currently most\n    # overloaded expert) generally requires these sequential updates.\n    for i in range(num_log, num_phy):\n        redundant_indices = (weight / logcnt).max(dim=-1).indices\n        phy2log[:, i] = redundant_indices\n        rank[:, i] = logcnt[arangen, redundant_indices]\n        logcnt[arangen, redundant_indices] += 1\n    return phy2log, rank, logcnt\n>>>>>>> REPLACE\n<<<<<<< SEARCH\n    num_layers, num_logical_experts = weight.shape\n    assert num_logical_experts % num_groups == 0\n    group_size = num_logical_experts // num_groups\n    assert num_groups % num_nodes == 0\n    groups_per_node = num_groups // num_nodes\n    assert num_gpus % num_nodes == 0\n    assert num_physical_experts % num_gpus == 0\n    phy_experts_per_gpu = num_physical_experts // num_gpus\n=======\n    num_layers, num_logical_experts = weight.shape\n    # These asserts define the structural assumptions of the hierarchical setup,\n    # ensuring consistent sizing for groups, nodes, and GPUs.\n    assert num_logical_experts % num_groups == 0\n    group_size = num_logical_experts // num_groups\n    assert num_groups % num_nodes == 0\n    groups_per_node = num_groups // num_nodes\n    assert num_gpus % num_nodes == 0\n    assert num_physical_experts % num_gpus == 0\n    phy_experts_per_gpu = num_physical_experts // num_gpus\n>>>>>>> REPLACE\n<<<<<<< SEARCH\n    if weight.dtype != torch.float:\n        weight = weight.float()\n    \n    if num_groups % num_nodes == 0:\n        # use hierarchical load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, num_groups, num_nodes, num_gpus)\n    else:\n        # use global load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, 1, 1, num_gpus)\n    num_redundant_experts = num_replicas - num_logical_experts\n=======\n    # Ensure weight is float type and keep it on its original device (CPU or GPU).\n    if weight.dtype != torch.float:\n        weight = weight.float()\n    \n    # The hierarchical policy requires specific divisibility conditions for its\n    # structural mappings (e.g., experts per group, groups per node).\n    # If these conditions are not met, a 'global' balancing policy is used\n    # by treating all experts as one group on one node.\n    if num_groups % num_nodes == 0:\n        # use hierarchical load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, num_groups, num_nodes, num_gpus)\n    else:\n        # use global load-balance policy\n        # This path is taken when the strict divisibility for hierarchical\n        # grouping (num_groups % num_nodes == 0) is not met.\n        # It simplifies the problem to a single group on a single 'node'\n        # before replicating and packing to GPUs.\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, 1, 1, num_gpus)\n    num_redundant_experts = num_replicas - num_logical_experts\n>>>>>>> REPLACE"]}}}