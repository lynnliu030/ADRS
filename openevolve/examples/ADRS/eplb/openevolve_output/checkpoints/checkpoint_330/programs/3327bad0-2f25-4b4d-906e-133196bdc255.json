{"id": "3327bad0-2f25-4b4d-906e-133196bdc255", "code": "# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\non how the EPLB algorithm works.\n\"\"\"\n\n# EVOLVE-BLOCK-START\n\nimport torch\nimport heapq\n\n\ndef balanced_packing(weight: torch.Tensor,\n                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Pack n weighted objects to m packs, such that each bin contains exactly\n    n/m objects and the weights of all packs are as balanced as possible.\n\n    Parameters:\n        weight: [X, n], the weight of each item\n        num_packs: number of packs\n\n    Returns:\n        pack_index: [X, n], the pack index of each item\n        rank_in_pack: [X, n], the rank of the item in the pack\n    \"\"\"\n    num_layers, num_groups = weight.shape\n    assert num_groups % num_packs == 0\n    groups_per_pack = num_groups // num_packs\n\n    if groups_per_pack == 1:\n        pack_index = torch.arange(weight.size(-1),\n                                  dtype=torch.int64,\n                                  device=weight.device).expand(weight.shape)\n        rank_in_pack = torch.zeros_like(weight, dtype=torch.int64)\n        return pack_index, rank_in_pack\n\n    # Sort groups by weight in descending order.\n    # 'weight' is already float and on CPU from rebalance_experts,\n    # so no need for .float().cpu() here.\n    indices = weight.sort(-1, descending=True).indices\n\n    # Initialize pack_index and rank_in_pack.\n    # These will be fully populated, so `empty_like` is sufficient.\n    # They will be on the same device as 'weight' (i.e., CPU).\n    pack_index = torch.empty_like(weight, dtype=torch.int64)\n    rank_in_pack = torch.empty_like(pack_index)\n    \n    # Iterate over each layer. The greedy assignment per layer is sequential.\n    for i in range(num_layers):\n        # Min-heap for the current layer to keep track of pack loads.\n        # Elements are (current_load, pack_id)\n        # Initialize with all packs having 0 load.\n        pack_heap = [(0.0, p) for p in range(num_packs)]\n        heapq.heapify(pack_heap) # Build heap in O(num_packs)\n        \n        # Keep track of items assigned to each pack for the current layer.\n        current_pack_items = torch.zeros(num_packs, dtype=torch.int64, device=weight.device)\n\n        # For each layer, process groups in sorted order of their weights.\n        # `indices[i]` is a 1D tensor of group IDs for the current layer, sorted by weight.\n        layer_indices = indices[i]\n        \n        # Iterate through the group IDs sorted by weight.\n        for group_idx_in_sorted_list in range(num_groups):\n            # Get the actual group ID from the sorted indices.\n            group_id = layer_indices[group_idx_in_sorted_list].item()\n\n            # Get the pack with the minimum current load from the heap.\n            current_load, pack = heapq.heappop(pack_heap)\n\n            # Assign the group to the chosen pack.\n            # The `group_id` is the column index for the `pack_index` and `rank_in_pack` tensors.\n            pack_index[i, group_id] = pack\n            rank_in_pack[i, group_id] = current_pack_items[pack]\n\n            # Update pack item count for the chosen pack.\n            current_pack_items[pack] += 1\n            \n            # Calculate new load for the pack.\n            new_load = current_load + weight[i, group_id].item() # .item() for scalar arithmetic\n\n            # If the pack is not yet full, push it back to the heap with its new load.\n            if current_pack_items[pack] < groups_per_pack:\n                heapq.heappush(pack_heap, (new_load, pack))\n            # Else, the pack is full, do not push it back to the heap.\n            # It means this pack will not be considered for further assignments in this layer.\n    return pack_index, rank_in_pack\n\n\ndef replicate_experts(\n        weight: torch.Tensor,\n        num_phy: int) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Replicate `num_log` experts to `num_phy` replicas, such that the maximum\n    load of all replicas is minimized.\n\n    Parameters:\n        weight: [X, num_log]\n        num_phy: total number of experts after replication\n\n    Returns:\n        phy2log: [X, num_phy], logical expert id of each physical expert\n        rank: [X, num_phy], the replica rank\n        logcnt: [X, num_log], number of replicas for each logical expert\n    \"\"\"\n    n, num_log = weight.shape\n    num_redundant = num_phy - num_log\n    assert num_redundant >= 0\n    device = weight.device\n    phy2log = torch.arange(num_phy, dtype=torch.int64,\n                           device=device).repeat(n, 1)\n    rank = torch.zeros(n, num_phy, dtype=torch.int64, device=device)\n    logcnt = torch.ones(n, num_log, dtype=torch.int64, device=device)\n    arangen = torch.arange(n, dtype=torch.int64, device=device)\n    # Initialize max-heaps for each layer\n    # Heap elements: (-average_load, logical_expert_id)\n    # Use negative average_load for max-heap behavior with heapq (which is a min-heap).\n    expert_heaps = []\n    for i_layer in range(n):\n        layer_heap = []\n        for j_expert in range(num_log):\n            # Initial average load is just the weight itself (since logcnt is 1 for initial experts)\n            heapq.heappush(layer_heap, (-weight[i_layer, j_expert].item(), j_expert))\n        expert_heaps.append(layer_heap)\n\n    # Assign redundant experts\n    for i_phy in range(num_log, num_phy): # Iterate num_redundant times\n        for i_layer in range(n): # Iterate over each layer\n            current_heap = expert_heaps[i_layer]\n            \n            # Pop the expert with the highest average load (min negative load)\n            neg_avg_load, log_expert_id = heapq.heappop(current_heap)\n            \n            # Assign this expert as a physical replica\n            phy2log[i_layer, i_phy] = log_expert_id\n            rank[i_layer, i_phy] = logcnt[i_layer, log_expert_id] # Replica rank for this expert\n            \n            # Increment count for this logical expert\n            logcnt[i_layer, log_expert_id] += 1\n            \n            # Calculate new average load and push back to heap\n            # Use .item() to get Python scalar for heap operations.\n            new_avg_load = weight[i_layer, log_expert_id].item() / logcnt[i_layer, log_expert_id].item()\n            heapq.heappush(current_heap, (-new_avg_load, log_expert_id))\n\n    return phy2log, rank, logcnt\n\n\ndef rebalance_experts_hierarchical(\n    weight: torch.Tensor,\n    num_physical_experts: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n):\n    \"\"\"\n    Parameters:\n        weight: [num_moe_layers, num_logical_experts]\n        num_physical_experts: number of physical experts after replication\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n        (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [num_moe_layers, num_physical_experts]\n        logical_to_physical_map: [num_moe_layers, num_logical_experts, X]\n        logical_count: [num_moe_layers, num_logical_experts]\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    assert num_logical_experts % num_groups == 0\n    group_size = num_logical_experts // num_groups\n    assert num_groups % num_nodes == 0\n    groups_per_node = num_groups // num_nodes\n    assert num_gpus % num_nodes == 0\n    assert num_physical_experts % num_gpus == 0\n    phy_experts_per_gpu = num_physical_experts // num_gpus\n\n    def inverse(perm: torch.Tensor) -> torch.Tensor:\n        inv = torch.empty_like(perm)\n        inv.scatter_(\n            1,\n            perm,\n            torch.arange(perm.size(1), dtype=torch.int64,\n                         device=perm.device).expand(perm.shape),\n        )\n        return inv\n\n    # Step 1: pack groups to nodes\n    tokens_per_group = weight.unflatten(-1, (num_groups, group_size)).sum(-1)\n    group_pack_index, group_rank_in_pack = balanced_packing(\n        tokens_per_group, num_nodes)\n    log2mlog = (((group_pack_index * groups_per_node + group_rank_in_pack) *\n                 group_size).unsqueeze(-1) +\n                torch.arange(group_size,\n                             dtype=torch.int64,\n                             device=group_pack_index.device)).flatten(-2)\n    mlog2log = inverse(log2mlog)\n\n    # Step 2: construct redundant experts within nodes\n    # [num_layers * num_nodes, num_logical_experts // num_nodes]\n    tokens_per_mlog = weight.gather(-1, mlog2log).view(\n        -1, num_logical_experts // num_nodes)\n    phy2mlog, phyrank, mlogcnt = replicate_experts(\n        tokens_per_mlog, num_physical_experts // num_nodes)\n\n    # Step 3: pack physical_experts to GPUs\n    # [num_layers * num_nodes, num_physical_experts // num_nodes]\n    tokens_per_phy = (tokens_per_mlog / mlogcnt).gather(-1, phy2mlog)\n    pack_index, rank_in_pack = balanced_packing(tokens_per_phy,\n                                                num_gpus // num_nodes)\n    phy2pphy = pack_index * phy_experts_per_gpu + rank_in_pack\n    pphy2phy = inverse(phy2pphy)\n\n    pphy2mlog = phy2mlog.gather(\n        -1, pphy2phy)  # [num_layers * num_nodes, num_log_per_nodes]\n    pphy2mlog = (pphy2mlog.view(num_layers, num_nodes, -1) + torch.arange(\n        0,\n        num_logical_experts,\n        num_logical_experts // num_nodes,\n        device=group_pack_index.device,\n    ).view(1, -1, 1)).flatten(-2)\n    pphy2log = mlog2log.gather(-1, pphy2mlog)\n    pphyrank = phyrank.gather(-1, pphy2phy).view(num_layers, -1)\n    logcnt = mlogcnt.view(num_layers, -1).gather(-1, log2mlog)\n    return pphy2log, pphyrank, logcnt\n\n\ndef rebalance_experts(\n    weight: torch.Tensor,\n    num_replicas: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Entry point for expert-parallelism load balancer.\n\n    Parameters:\n        weight: [layers, num_logical_experts], the load statistics for all\n            logical experts\n        num_replicas: number of physical experts, must be a multiple of\n            `num_gpus`\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n            (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [layers, num_replicas], the expert index of\n            each replica\n        logical_to_physical_map: [layers, num_logical_experts, X], the replica\n            indices for each expert\n        expert_count: [layers, num_logical_experts], number of physical\n            replicas for each logical expert\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    \n    # Store original device to move results back later.\n    original_device = weight.device\n    \n    # Cast weight to float for calculations and move to CPU.\n    # Python's heapq and scalar operations (.item()) are efficient on CPU tensors.\n    weight = weight.float().cpu()\n    \n    if num_groups % num_nodes == 0:\n        # use hierarchical load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, num_groups, num_nodes, num_gpus)\n    else:\n        # use global load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, 1, 1, num_gpus)\n    num_redundant_experts = num_replicas - num_logical_experts\n    maxlogcnt = num_redundant_experts + 1\n    log2phy: torch.Tensor = torch.full(\n        (num_layers, num_logical_experts, maxlogcnt),\n        -1,\n        dtype=torch.int64,\n        device=logcnt.device,\n    )\n    log2phy.view(num_layers, -1).scatter_(\n        -1,\n        phy2log * maxlogcnt + phyrank,\n        torch.arange(num_replicas, dtype=torch.int64,\n                     device=log2phy.device).expand(num_layers, -1),\n    )\n    \n    # Move results back to the original device.\n    phy2log = phy2log.to(original_device)\n    log2phy = log2phy.to(original_device)\n    logcnt = logcnt.to(original_device)\n    \n    return phy2log, log2phy, logcnt\n\n\n# EVOLVE-BLOCK-END\n\n__all__ = [\"rebalance_experts\"]\n\n", "language": "python", "parent_id": "3b44deaa-31cc-4f36-9b52-b1a037857a67", "generation": 10, "timestamp": 1751068938.9405134, "iteration_found": 299, "metrics": {"balancedness_score": 0.29830835153138974, "speed_score": 0.03538940485806217, "combined_score": 0.16684887819472596}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 75 lines with 79 lines", "parent_metrics": {"balancedness_score": 0.29830835153138974, "speed_score": 0.03541486937401876, "combined_score": 0.16686161045270426}, "island": 4}, "artifacts_json": null, "artifact_dir": null, "prompts": {"diff_user": {"system": "You are an expert programmer specializing in optimization algorithms. Your task is to improve the Mixture-of-Expert models Expert Parallelism Load Balancer (MoE EPLB) expert rearrangement algorithm.\nThis algorithm will take the load metrics recorded by the vLLM server, and rearrange the experts to balance the load. It can make replicas of some experts to achieve better load balancing.\nYour goal will be two-fold: 1. Improve the algorithm to achieve better load balancing; while 2. Improve the algorithm to be more efficient, i.e. reduce the execution time of the algorithm itself, since perfect load balancing is NP-hard.\nThe current algorithm is implemented in the `rebalance_experts` function. ", "user": "# Current Program Information\n- Current performance metrics: - balancedness_score: 0.2983\n- speed_score: 0.0354\n- combined_score: 0.1669\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: balancedness_score, speed_score, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: balancedness_score: 0.3528, speed_score: 0.1125, combined_score: 0.2326\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: balancedness_score: 0.3528, speed_score: 0.1126, combined_score: 0.2327\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: balancedness_score: 0.3528, speed_score: 0.1143, combined_score: 0.2335\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.2335)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\n# ... (truncated for brevity)\n```\nKey features: Performs well on balancedness_score (0.3528), Performs well on speed_score (0.1143), Performs well on combined_score (0.2335)\n\n\n### Program 2 (Score: 0.2327)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\n# ... (truncated for brevity)\n```\nKey features: Performs well on balancedness_score (0.3528), Performs well on speed_score (0.1126), Performs well on combined_score (0.2327)\n\n\n### Program 3 (Score: 0.2326)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\n# ... (truncated for brevity)\n```\nKey features: Performs well on balancedness_score (0.3528), Performs well on speed_score (0.1125), Performs well on combined_score (0.2326)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.2322)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n# ... (truncated)\n```\nKey features: Alternative approach to balancedness_score, Alternative approach to speed_score\n\n\n### Program D2 (Score: 0.2325)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n# ... (truncated)\n```\nKey features: Alternative approach to balancedness_score, Alternative approach to speed_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.2335, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Modification: Change 1: Replace 32 lines with 17 lines, Alternative speed_score approach, Alternative combined_score approach\n\n\n### Inspiration 2 (Score: 0.0939, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Modification: Change 1: Replace 23 lines with 236 lines, Alternative balancedness_score approach, Alternative speed_score approach\n\n\n### Inspiration 3 (Score: 0.0939, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Modification: Change 1: Replace 23 lines with 236 lines, Alternative balancedness_score approach, Alternative speed_score approach\n\n\n### Inspiration 4 (Score: 0.0000, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Modification: Change 1: Replace 25 lines with 53 lines, Alternative balancedness_score approach, Alternative speed_score approach\n\n\n### Inspiration 5 (Score: 0.0000, Type: Exploratory)\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n# ... (truncated for brevity)\n```\nUnique approach: Alternative balancedness_score approach, Alternative speed_score approach, Alternative combined_score approach\n\n\n\n# Current Program\n```python\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nExpert parallelism load balancer (EPLB) for vLLM.\n\nThis module implements the core rearrangement algorithm.\n\nThe rearrangement algorithm is adapted from\n[DeepSeek EPLB](https://github.com/deepseek-ai/eplb).\n\nPlease find at [#12](https://github.com/deepseek-ai/EPLB/issues/12) an example\non how the EPLB algorithm works.\n\"\"\"\n\n# EVOLVE-BLOCK-START\n\nimport torch\nimport heapq\n\n\ndef balanced_packing(weight: torch.Tensor,\n                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Pack n weighted objects to m packs, such that each bin contains exactly\n    n/m objects and the weights of all packs are as balanced as possible.\n\n    Parameters:\n        weight: [X, n], the weight of each item\n        num_packs: number of packs\n\n    Returns:\n        pack_index: [X, n], the pack index of each item\n        rank_in_pack: [X, n], the rank of the item in the pack\n    \"\"\"\n    num_layers, num_groups = weight.shape\n    assert num_groups % num_packs == 0\n    groups_per_pack = num_groups // num_packs\n\n    if groups_per_pack == 1:\n        pack_index = torch.arange(weight.size(-1),\n                                  dtype=torch.int64,\n                                  device=weight.device).expand(weight.shape)\n        rank_in_pack = torch.zeros_like(weight, dtype=torch.int64)\n        return pack_index, rank_in_pack\n\n    # Sort groups by weight in descending order.\n    # 'weight' is already float and on CPU from rebalance_experts,\n    # so no need for .float().cpu() here.\n    indices = weight.sort(-1, descending=True).indices\n\n    # Initialize pack_index and rank_in_pack.\n    # These will be fully populated, so `empty_like` is sufficient.\n    # They will be on the same device as 'weight' (i.e., CPU).\n    pack_index = torch.empty_like(weight, dtype=torch.int64)\n    rank_in_pack = torch.empty_like(pack_index)\n    \n    # Iterate over each layer. The greedy assignment per layer is sequential.\n    for i in range(num_layers):\n        # Min-heap for the current layer to keep track of pack loads.\n        # Elements are (current_load, pack_id)\n        # Initialize with all packs having 0 load.\n        pack_heap = [(0.0, p) for p in range(num_packs)]\n        heapq.heapify(pack_heap) # Build heap in O(num_packs)\n        \n        # Keep track of items assigned to each pack for the current layer.\n        current_pack_items = torch.zeros(num_packs, dtype=torch.int64, device=weight.device)\n\n        # For each layer, process groups in sorted order of their weights.\n        # `indices[i]` is a 1D tensor of group IDs for the current layer, sorted by weight.\n        layer_indices = indices[i]\n        \n        # Iterate through the group IDs sorted by weight.\n        for group_idx_in_sorted_list in range(num_groups):\n            # Get the actual group ID from the sorted indices.\n            group_id = layer_indices[group_idx_in_sorted_list].item()\n\n            # Get the pack with the minimum current load from the heap.\n            current_load, pack = heapq.heappop(pack_heap)\n\n            # Assign the group to the chosen pack.\n            # The `group_id` is the column index for the `pack_index` and `rank_in_pack` tensors.\n            pack_index[i, group_id] = pack\n            rank_in_pack[i, group_id] = current_pack_items[pack]\n\n            # Update pack item count for the chosen pack.\n            current_pack_items[pack] += 1\n            \n            # Calculate new load for the pack.\n            new_load = current_load + weight[i, group_id].item() # .item() for scalar arithmetic\n\n            # If the pack is not yet full, push it back to the heap with its new load.\n            if current_pack_items[pack] < groups_per_pack:\n                heapq.heappush(pack_heap, (new_load, pack))\n            # Else, the pack is full, do not push it back to the heap.\n            # It means this pack will not be considered for further assignments in this layer.\n    return pack_index, rank_in_pack\n\n\ndef replicate_experts(\n        weight: torch.Tensor,\n        num_phy: int) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Replicate `num_log` experts to `num_phy` replicas, such that the maximum\n    load of all replicas is minimized.\n\n    Parameters:\n        weight: [X, num_log]\n        num_phy: total number of experts after replication\n\n    Returns:\n        phy2log: [X, num_phy], logical expert id of each physical expert\n        rank: [X, num_phy], the replica rank\n        logcnt: [X, num_log], number of replicas for each logical expert\n    \"\"\"\n    n, num_log = weight.shape\n    num_redundant = num_phy - num_log\n    assert num_redundant >= 0\n    device = weight.device\n    phy2log = torch.arange(num_phy, dtype=torch.int64,\n                           device=device).repeat(n, 1)\n    rank = torch.zeros(n, num_phy, dtype=torch.int64, device=device)\n    logcnt = torch.ones(n, num_log, dtype=torch.int64, device=device)\n    arangen = torch.arange(n, dtype=torch.int64, device=device)\n    # Initialize max-heaps for each layer\n    # Heap elements: (-average_load, logical_expert_id)\n    # Use negative average_load for max-heap behavior with heapq (which is a min-heap).\n    expert_heaps = []\n    for i_layer in range(n):\n        layer_heap = []\n        for j_expert in range(num_log):\n            # Initial average load is just the weight itself (since logcnt is 1 for initial experts)\n            heapq.heappush(layer_heap, (-weight[i_layer, j_expert].item(), j_expert))\n        expert_heaps.append(layer_heap)\n\n    # Assign redundant experts\n    for i_phy in range(num_log, num_phy): # Iterate num_redundant times\n        for i_layer in range(n): # Iterate over each layer\n            current_heap = expert_heaps[i_layer]\n            \n            # Pop the expert with the highest average load (min negative load)\n            neg_avg_load, log_expert_id = heapq.heappop(current_heap)\n            \n            # Assign this expert as a physical replica\n            phy2log[i_layer, i_phy] = log_expert_id\n            rank[i_layer, i_phy] = logcnt[i_layer, log_expert_id] # Replica rank for this expert\n            \n            # Increment count for this logical expert\n            logcnt[i_layer, log_expert_id] += 1\n            \n            # Calculate new average load and push back to heap\n            # Use .item() to get Python scalar for heap operations.\n            new_avg_load = weight[i_layer, log_expert_id].item() / logcnt[i_layer, log_expert_id].item()\n            heapq.heappush(current_heap, (-new_avg_load, log_expert_id))\n\n    return phy2log, rank, logcnt\n\n\ndef rebalance_experts_hierarchical(\n    weight: torch.Tensor,\n    num_physical_experts: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n):\n    \"\"\"\n    Parameters:\n        weight: [num_moe_layers, num_logical_experts]\n        num_physical_experts: number of physical experts after replication\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n        (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [num_moe_layers, num_physical_experts]\n        logical_to_physical_map: [num_moe_layers, num_logical_experts, X]\n        logical_count: [num_moe_layers, num_logical_experts]\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    assert num_logical_experts % num_groups == 0\n    group_size = num_logical_experts // num_groups\n    assert num_groups % num_nodes == 0\n    groups_per_node = num_groups // num_nodes\n    assert num_gpus % num_nodes == 0\n    assert num_physical_experts % num_gpus == 0\n    phy_experts_per_gpu = num_physical_experts // num_gpus\n\n    def inverse(perm: torch.Tensor) -> torch.Tensor:\n        inv = torch.empty_like(perm)\n        inv.scatter_(\n            1,\n            perm,\n            torch.arange(perm.size(1), dtype=torch.int64,\n                         device=perm.device).expand(perm.shape),\n        )\n        return inv\n\n    # Step 1: pack groups to nodes\n    tokens_per_group = weight.unflatten(-1, (num_groups, group_size)).sum(-1)\n    group_pack_index, group_rank_in_pack = balanced_packing(\n        tokens_per_group, num_nodes)\n    log2mlog = (((group_pack_index * groups_per_node + group_rank_in_pack) *\n                 group_size).unsqueeze(-1) +\n                torch.arange(group_size,\n                             dtype=torch.int64,\n                             device=group_pack_index.device)).flatten(-2)\n    mlog2log = inverse(log2mlog)\n\n    # Step 2: construct redundant experts within nodes\n    # [num_layers * num_nodes, num_logical_experts // num_nodes]\n    tokens_per_mlog = weight.gather(-1, mlog2log).view(\n        -1, num_logical_experts // num_nodes)\n    phy2mlog, phyrank, mlogcnt = replicate_experts(\n        tokens_per_mlog, num_physical_experts // num_nodes)\n\n    # Step 3: pack physical_experts to GPUs\n    # [num_layers * num_nodes, num_physical_experts // num_nodes]\n    tokens_per_phy = (tokens_per_mlog / mlogcnt).gather(-1, phy2mlog)\n    pack_index, rank_in_pack = balanced_packing(tokens_per_phy,\n                                                num_gpus // num_nodes)\n    phy2pphy = pack_index * phy_experts_per_gpu + rank_in_pack\n    pphy2phy = inverse(phy2pphy)\n\n    pphy2mlog = phy2mlog.gather(\n        -1, pphy2phy)  # [num_layers * num_nodes, num_log_per_nodes]\n    pphy2mlog = (pphy2mlog.view(num_layers, num_nodes, -1) + torch.arange(\n        0,\n        num_logical_experts,\n        num_logical_experts // num_nodes,\n        device=group_pack_index.device,\n    ).view(1, -1, 1)).flatten(-2)\n    pphy2log = mlog2log.gather(-1, pphy2mlog)\n    pphyrank = phyrank.gather(-1, pphy2phy).view(num_layers, -1)\n    logcnt = mlogcnt.view(num_layers, -1).gather(-1, log2mlog)\n    return pphy2log, pphyrank, logcnt\n\n\ndef rebalance_experts(\n    weight: torch.Tensor,\n    num_replicas: int,\n    num_groups: int,\n    num_nodes: int,\n    num_gpus: int,\n) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Entry point for expert-parallelism load balancer.\n\n    Parameters:\n        weight: [layers, num_logical_experts], the load statistics for all\n            logical experts\n        num_replicas: number of physical experts, must be a multiple of\n            `num_gpus`\n        num_groups: number of expert groups\n        num_nodes: number of server nodes, where the intra-node network\n            (e.g, NVLink) is faster\n        num_gpus: number of GPUs, must be a multiple of `num_nodes`\n\n    Returns:\n        physical_to_logical_map: [layers, num_replicas], the expert index of\n            each replica\n        logical_to_physical_map: [layers, num_logical_experts, X], the replica\n            indices for each expert\n        expert_count: [layers, num_logical_experts], number of physical\n            replicas for each logical expert\n    \"\"\"\n    num_layers, num_logical_experts = weight.shape\n    \n    # Store original device to move results back later.\n    original_device = weight.device\n    \n    # Cast weight to float for calculations and move to CPU.\n    # Python's heapq and scalar operations (.item()) are efficient on CPU tensors.\n    weight = weight.float().cpu()\n    \n    if num_groups % num_nodes == 0:\n        # use hierarchical load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, num_groups, num_nodes, num_gpus)\n    else:\n        # use global load-balance policy\n        phy2log, phyrank, logcnt = rebalance_experts_hierarchical(\n            weight, num_replicas, 1, 1, num_gpus)\n    num_redundant_experts = num_replicas - num_logical_experts\n    maxlogcnt = num_redundant_experts + 1\n    log2phy: torch.Tensor = torch.full(\n        (num_layers, num_logical_experts, maxlogcnt),\n        -1,\n        dtype=torch.int64,\n        device=logcnt.device,\n    )\n    log2phy.view(num_layers, -1).scatter_(\n        -1,\n        phy2log * maxlogcnt + phyrank,\n        torch.arange(num_replicas, dtype=torch.int64,\n                     device=log2phy.device).expand(num_layers, -1),\n    )\n    \n    # Move results back to the original device.\n    phy2log = phy2log.to(original_device)\n    log2phy = log2phy.to(original_device)\n    logcnt = logcnt.to(original_device)\n    \n    return phy2log, log2phy, logcnt\n\n\n# EVOLVE-BLOCK-END\n\n__all__ = [\"rebalance_experts\"]\n\n\n```\n\n# Task\nSuggest improvements to the program that will lead to better performance on the specified metrics.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.\n", "responses": ["The current program shows a regression in both `balancedness_score` and `speed_score` compared to previous attempts. The analysis suggests that the primary bottleneck for speed might be the frequent use of Python's `heapq` and scalar `item()` calls within tight loops, especially in `balanced_packing` and `replicate_experts`. While `heapq` is asymptotically efficient for priority queue operations, the overhead of Python object manipulation and tensor-to-scalar conversions can be significant for practical problem sizes.\n\nFor `replicate_experts`, where the number of logical experts (`num_log`) can be large, the `O(log num_log)` complexity of `heapq` is crucial, and replacing it with a `torch.argmin` based approach (which would be `O(num_log)`) would likely make it slower. Thus, `replicate_experts` is likely performing as well as it can with `heapq` given the constraints.\n\nHowever, for `balanced_packing`, the number of packs (`num_packs`) is typically small (e.g., `num_nodes` or `num_gpus // num_nodes`). In such cases, the `O(num_packs)` complexity of `torch.argmin` might be faster than `O(log num_packs)` with Python overhead. By replacing the `heapq`-based greedy assignment with a pure PyTorch tensor-based approach using `torch.argmin`, we can eliminate all `heapq` calls and `item()` calls within the main loop of `balanced_packing`, leading to a significant reduction in Python overhead. This change preserves the core Longest Processing Time (LPT) heuristic, so the `balancedness_score` should not be adversely affected, while `speed_score` is expected to improve.\n\nThe change replaces the `heapq` logic in `balanced_packing` with direct tensor operations for managing pack loads and counts.\n\n**Reasoning for the change:**\n\n1.  **Reduced Python Overhead:** The original `balanced_packing` function used Python's `heapq` module and frequently called `.item()` on PyTorch tensors to convert them to Python scalars for heap operations. This introduces significant overhead, especially within the inner loop that iterates `num_groups` times for each layer. The proposed change removes all `heapq` and `.item()` calls from this inner loop.\n2.  **Leveraging PyTorch Optimizations:** By performing operations like finding the minimum load pack (`torch.argmin`) and updating loads/counts directly on PyTorch tensors, we leverage highly optimized C++/CUDA implementations, which are much faster than equivalent Python operations.\n3.  **Preserving Algorithm Correctness:** The new implementation of `balanced_packing` still follows the Longest Processing Time (LPT) heuristic, which involves sorting items by weight and assigning them to the pack with the minimum current load. The logic for handling full packs is also maintained. Therefore, the load balancing quality (`balancedness_score`) should remain comparable.\n4.  **Applicability to `balanced_packing`:** This optimization is particularly effective for `balanced_packing` because `num_packs` (the size of the array `torch.argmin` operates on) is typically small (e.g., number of nodes or GPUs per node). For small array sizes, the constant factor overhead of Python `heapq` operations can easily outweigh the `log(N)` asymptotic advantage, making the `O(N)` `argmin` on a highly optimized backend faster in practice.\n\nThis targeted change should improve the `speed_score` without sacrificing `balancedness_score`, leading to a better `combined_score`.\n\n```python\n<<<<<<< SEARCH\ndef balanced_packing(weight: torch.Tensor,\n                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Pack n weighted objects to m packs, such that each bin contains exactly\n    n/m objects and the weights of all packs are as balanced as possible.\n\n    Parameters:\n        weight: [X, n], the weight of each item\n        num_packs: number of packs\n\n    Returns:\n        pack_index: [X, n], the pack index of each item\n        rank_in_pack: [X, n], the rank of the item in the pack\n    \"\"\"\n    num_layers, num_groups = weight.shape\n    assert num_groups % num_packs == 0\n    groups_per_pack = num_groups // num_packs\n\n    if groups_per_pack == 1:\n        pack_index = torch.arange(weight.size(-1),\n                                  dtype=torch.int64,\n                                  device=weight.device).expand(weight.shape)\n        rank_in_pack = torch.zeros_like(weight, dtype=torch.int64)\n        return pack_index, rank_in_pack\n\n    # Sort groups by weight in descending order.\n    # 'weight' is already float and on CPU from rebalance_experts,\n    # so no need for .float().cpu() here.\n    indices = weight.sort(-1, descending=True).indices\n\n    # Initialize pack_index and rank_in_pack.\n    # These will be fully populated, so `empty_like` is sufficient.\n    # They will be on the same device as 'weight' (i.e., CPU).\n    pack_index = torch.empty_like(weight, dtype=torch.int64)\n    rank_in_pack = torch.empty_like(pack_index)\n    \n    # Iterate over each layer. The greedy assignment per layer is sequential.\n    for i in range(num_layers):\n        # Min-heap for the current layer to keep track of pack loads.\n        # Elements are (current_load, pack_id)\n        # Initialize with all packs having 0 load.\n        pack_heap = [(0.0, p) for p in range(num_packs)]\n        heapq.heapify(pack_heap) # Build heap in O(num_packs)\n        \n        # Keep track of items assigned to each pack for the current layer.\n        current_pack_items = torch.zeros(num_packs, dtype=torch.int64, device=weight.device)\n\n        # For each layer, process groups in sorted order of their weights.\n        # `indices[i]` is a 1D tensor of group IDs for the current layer, sorted by weight.\n        \n        # Iterate through the group IDs sorted by weight.\n        for group_idx_in_sorted_list in range(num_groups):\n            # Get the actual group ID from the sorted indices.\n            group_id = layer_indices[group_idx_in_sorted_list].item()\n\n            # Get the pack with the minimum current load from the heap.\n            current_load, pack = heapq.heappop(pack_heap)\n\n            # Assign the group to the chosen pack.\n            # The `group_id` is the column index for the `pack_index` and `rank_in_pack` tensors.\n            pack_index[i, group_id] = pack\n            rank_in_pack[i, group_id] = current_pack_items[pack]\n\n            # Update pack item count for the chosen pack.\n            current_pack_items[pack] += 1\n            \n            # Calculate new load for the pack.\n            new_load = current_load + weight[i, group_id].item() # .item() for scalar arithmetic\n\n            # If the pack is not yet full, push it back to the heap with its new load.\n            if current_pack_items[pack] < groups_per_pack:\n                heapq.heappush(pack_heap, (new_load, pack))\n            # Else, the pack is full, do not push it back to the heap.\n            # It means this pack will not be considered for further assignments in this layer.\n    return pack_index, rank_in_pack\n=======\ndef balanced_packing(weight: torch.Tensor,\n                     num_packs: int) -> tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Pack n weighted objects to m packs, such that each bin contains exactly\n    n/m objects and the weights of all packs are as balanced as possible.\n\n    Parameters:\n        weight: [X, n], the weight of each item\n        num_packs: number of packs\n\n    Returns:\n        pack_index: [X, n], the pack index of each item\n        rank_in_pack: [X, n], the rank of the item in the pack\n    \"\"\"\n    num_layers, num_groups = weight.shape\n    assert num_groups % num_packs == 0\n    groups_per_pack = num_groups // num_packs\n\n    if groups_per_pack == 1:\n        pack_index = torch.arange(weight.size(-1),\n                                  dtype=torch.int64,\n                                  device=weight.device).expand(weight.shape)\n        rank_in_pack = torch.zeros_like(weight, dtype=torch.int64)\n        return pack_index, rank_in_pack\n\n    # Sort groups by weight in descending order.\n    # 'weight' is already float and on CPU from rebalance_experts,\n    # so no need for .float().cpu() here.\n    # We need both sorted weights and their original indices.\n    sorted_weights, sorted_indices = weight.sort(-1, descending=True)\n\n    # Initialize pack_index and rank_in_pack.\n    # These will be fully populated, so `empty_like` is sufficient.\n    # They will be on the same device as 'weight' (i.e., CPU).\n    pack_index = torch.empty_like(weight, dtype=torch.int64)\n    rank_in_pack = torch.empty_like(pack_index)\n    \n    # Iterate over each layer. The greedy assignment per layer is sequential.\n    for i in range(num_layers):\n        # Current loads for each pack in this layer, initialized to 0.\n        # This will be a tensor, allowing direct tensor operations.\n        current_pack_loads = torch.zeros(num_packs, dtype=torch.float32, device=weight.device)\n        # Count of items in each pack\n        current_pack_items_count = torch.zeros(num_packs, dtype=torch.int64, device=weight.device)\n\n        # For each layer, process groups in sorted order of their weights.\n        # `sorted_indices[i]` is a 1D tensor of group IDs for the current layer, sorted by weight.\n        # `sorted_weights[i]` is a 1D tensor of weights for the current layer, sorted by weight.\n        \n        # Iterate through the group IDs and weights sorted by weight.\n        for j in range(num_groups): # Iterates num_groups times\n            # Get the actual group ID and its weight (as 0-dim tensors)\n            group_id = sorted_indices[i, j]\n            group_weight = sorted_weights[i, j]\n\n            # Find the pack with the minimum current load that is not yet full.\n            # Create a mask for full packs.\n            full_packs_mask = (current_pack_items_count >= groups_per_pack)\n            \n            # To find min load among non-full packs, set loads of full packs to a very large value.\n            # Use clone() to avoid modifying current_pack_loads in place before the argmin.\n            temp_loads = current_pack_loads.clone()\n            # Assigning float('inf') to a tensor element is fine.\n            temp_loads[full_packs_mask] = float('inf') \n\n            # Find the pack with the minimum load.\n            # argmin returns a 0-dim tensor.\n            pack = torch.argmin(temp_loads) \n\n            # Assign the group to the chosen pack.\n            # group_id and pack are 0-dim tensors, which can be used for indexing directly.\n            pack_index[i, group_id] = pack\n            rank_in_pack[i, group_id] = current_pack_items_count[pack]\n\n            # Update pack load and item count using tensor operations.\n            current_pack_loads[pack] += group_weight\n            current_pack_items_count[pack] += 1\n            \n    return pack_index, rank_in_pack\n>>>>>>> REPLACE\n```"]}}}