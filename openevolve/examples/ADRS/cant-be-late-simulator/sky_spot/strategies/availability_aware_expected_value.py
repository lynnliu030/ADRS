"""
Availability-Aware Expected Value (AAEV) Strategy

Uses pre-computed region characteristics to select regions based on expected duration.
Tries regions in descending order of expected value (availability × avg_duration).
Respects information isolation by using hardcoded statistics from offline analysis.
"""

import argparse
import logging
import typing
from typing import List, Tuple

from sky_spot.strategies.strategy import MultiRegionStrategy
from sky_spot.utils import ClusterType

if typing.TYPE_CHECKING:
    from sky_spot import env
    from sky_spot import task
    from sky_spot.multi_region_types import Action, LaunchResult

logger = logging.getLogger(__name__)

# Hardcoded region characteristics from offline analysis
# Generated by analyze_region_characteristics.py
REGION_CHARACTERISTICS = {
    'us-east-1a_v100_1': {
        'avg_availability': 0.2193,
        'avg_duration': 0.7282,
        'expected_value': 0.1597,
        'region_index': 0
    },
    'us-east-1d_v100_1': {
        'avg_availability': 0.5385,
        'avg_duration': 2.3524,
        'expected_value': 1.2667,
        'region_index': 1
    },
    'us-east-1c_v100_1': {
        'avg_availability': 0.5587,
        'avg_duration': 2.1241,
        'expected_value': 1.1868,
        'region_index': 2
    },
    'us-east-1f_v100_1': {
        'avg_availability': 0.6186,
        'avg_duration': 2.5427,
        'expected_value': 1.5729,
        'region_index': 3
    },
    'us-east-2a_v100_1': {
        'avg_availability': 0.8657,
        'avg_duration': 12.4883,
        'expected_value': 10.8108,
        'region_index': 4
    },
}

# Region priority order (by expected value, descending)
REGION_PRIORITY_ORDER = [
    4,  # us-east-2a_v100_1: 10.81h expected
    3,  # us-east-1f_v100_1: 1.57h expected
    1,  # us-east-1d_v100_1: 1.27h expected
    2,  # us-east-1c_v100_1: 1.19h expected
    0,  # us-east-1a_v100_1: 0.16h expected
]


class AvailabilityAwareExpectedValueStrategy(MultiRegionStrategy):
    NAME = 'availability_aware_expected_value'
    
    def __init__(self, args):
        super().__init__(args)
        logger.info(f"Initialized AAEV strategy with hardcoded region characteristics")
    
    def reset(self, env: 'env.Env', task: 'task.Task'):
        super().reset(env, task)
        logger.info("AAEV strategy reset")
    
    def _step_multi(self) -> typing.Generator['Action', typing.Optional['LaunchResult'], None]:
        """Multi-region step using expected value selection with proper time-based decisions."""
        from sky_spot.multi_region_types import TryLaunch, Terminate
        
        env = typing.cast('env.MultiTraceEnv', self.env)
        
        # Assert we only maintain one instance at a time
        active_instances = env.get_active_instances()
        assert len(active_instances) <= 1, f"AAEV should only have at most 1 instance, got {len(active_instances)}"
        
        # Get current state
        last_cluster_type = ClusterType.NONE
        last_region = None
        if active_instances:
            last_region = list(active_instances.keys())[0]
            last_cluster_type = active_instances[last_region]
        
        # Check if task is done
        remaining_task_time = self.task_duration - sum(self.task_done_time)
        if remaining_task_time <= 1e-3:
            if last_region is not None:
                logger.info("Task complete, terminating instance")
                yield Terminate(region=last_region)
            return
        
        # Decide what type of instance we need based on time pressure
        request_type = self._compute_request_type(last_cluster_type, has_spot=True)  # Treat SPOT as desirable by default

        # If we already have an instance, change type with minimal thrash
        if last_region is not None:
            # No change needed
            if request_type == last_cluster_type:
                logger.debug(f"Keeping {last_cluster_type.name} in region {last_region}")
                return

            # Explicit shutdown with no replacement
            if request_type == ClusterType.NONE:
                logger.info(f"Terminating {last_cluster_type.name} in region {last_region} (request_type=NONE)")
                yield Terminate(region=last_region)
                return

            # Switching types: prefer launch-then-terminate when safe (different region)
            if request_type == ClusterType.SPOT:
                # Try to find a different region to avoid same-region same-tick overwrite rules
                launched_region: typing.Optional[int] = None
                for region_id in REGION_PRIORITY_ORDER:
                    if region_id >= env.num_regions:
                        continue
                    if region_id == last_region:
                        # Avoid launching in the same region before terminating
                        continue
                    logger.info(
                        f"Trying SPOT in region {region_id} (expected value: {self._get_expected_value(region_id):.2f}h) while keeping {last_cluster_type.name} in region {last_region}"
                    )
                    result = yield TryLaunch(region=region_id, cluster_type=ClusterType.SPOT)
                    assert result is not None
                    if result.success:
                        launched_region = region_id
                        break
                    else:
                        logger.debug(f"SPOT launch failed in region {region_id}")

                if launched_region is not None:
                    logger.info(
                        f"Switching to SPOT in region {launched_region}; terminating {last_cluster_type.name} in region {last_region}"
                    )
                    yield Terminate(region=last_region)
                    return

                # Could not launch SPOT elsewhere this tick – keep current instance to avoid downtime
                logger.debug("No SPOT region succeeded; keeping current instance this tick")
                return

            elif request_type == ClusterType.ON_DEMAND:
                best_region = 0
                if best_region == last_region:
                    # Same-region type change: must terminate first, then launch (ON_DEMAND always succeeds)
                    logger.info(
                        f"Switching to ON_DEMAND in same region {best_region}: terminating {last_cluster_type.name} then launching ON_DEMAND"
                    )
                    yield Terminate(region=last_region)
                    result = yield TryLaunch(region=best_region, cluster_type=ClusterType.ON_DEMAND)
                    assert result is not None
                    assert result.success, "ON_DEMAND should always succeed"
                    return
                else:
                    # Different region: launch first, then terminate
                    logger.info(
                        f"Launching ON_DEMAND in region {best_region} then terminating {last_cluster_type.name} in region {last_region}"
                    )
                    result = yield TryLaunch(region=best_region, cluster_type=ClusterType.ON_DEMAND)
                    assert result is not None
                    assert result.success, "ON_DEMAND should always succeed"
                    yield Terminate(region=last_region)
                    return
        
        # Try to launch the requested instance type
        if request_type == ClusterType.SPOT:
            # Try regions in expected value order
            launched = False
            for region_id in REGION_PRIORITY_ORDER:
                if region_id >= env.num_regions:
                    continue
                    
                logger.info(f"Trying SPOT in region {region_id} (expected value: {self._get_expected_value(region_id):.2f}h)")
                result = yield TryLaunch(region=region_id, cluster_type=ClusterType.SPOT)
                assert result is not None
                
                if result.success:
                    logger.info(f"Successfully launched SPOT in region {region_id}")
                    launched = True
                    break
                else:
                    logger.debug(f"SPOT launch failed in region {region_id}")
            
            if not launched:
                # No SPOT available, recompute with has_spot=False
                logger.info("No SPOT available in any region, recomputing decision")
                request_type = self._compute_request_type(ClusterType.NONE, has_spot=False)
                
                if request_type == ClusterType.ON_DEMAND:
                    best_region = 0
                    logger.info(f"Launching ON_DEMAND in region {best_region}")
                    result = yield TryLaunch(region=best_region, cluster_type=ClusterType.ON_DEMAND)
                    assert result is not None
                    assert result.success, "ON_DEMAND should always succeed"
                # else: request_type is NONE, don't launch anything
        
        elif request_type == ClusterType.ON_DEMAND:
            best_region = 0
            logger.info(f"Directly launching ON_DEMAND in region {best_region} due to time pressure")
            result = yield TryLaunch(region=best_region, cluster_type=ClusterType.ON_DEMAND)
            assert result is not None
            assert result.success, "ON_DEMAND should always succeed"
    
    def _compute_request_type(self, current_cluster_type: ClusterType, has_spot: bool) -> ClusterType:
        """Compute the request type using time-based logic similar to RC/CR."""
        import math
        
        env = self.env
        remaining_time = math.floor((self.deadline - env.elapsed_seconds) / env.gap_seconds) * env.gap_seconds
        remaining_task_time = self.task_duration - sum(self.task_done_time)
        
        # Default decision: prefer SPOT if available
        request_type = ClusterType.SPOT if has_spot else ClusterType.NONE
        
        # Apply uniform progress condition (similar to _condition in RC/CR)
        condition = self._uniform_progress_condition()
        if condition < 0:
            # Behind schedule, need more aggressive approach
            request_type = ClusterType.SPOT if has_spot else ClusterType.ON_DEMAND
            logger.debug(f"Behind schedule (condition={condition:.2f}), being aggressive")
        
        # Sticky ON_DEMAND logic: if already on ON_DEMAND, stay unless condition2 allows switch
        # if current_cluster_type == ClusterType.ON_DEMAND:
        #     condition2 = self._sticky_condition()
        #     if not has_spot or condition2 >= 0:
        #         request_type = ClusterType.ON_DEMAND
        #         logger.debug(f"Staying on ON_DEMAND (condition2={condition2:.2f}, has_spot={has_spot})")
        
        # Check deadline constraints
        total_task_remaining = math.ceil((remaining_task_time + self.restart_overhead) / env.gap_seconds) * env.gap_seconds
        total_task_remaining_with_2D = math.ceil((remaining_task_time + 2 * self.restart_overhead) / env.gap_seconds) * env.gap_seconds
        
        # Critical time pressure: need ON_DEMAND to guarantee completion
        if total_task_remaining_with_2D >= remaining_time and current_cluster_type in [ClusterType.NONE, ClusterType.ON_DEMAND]:
            request_type = ClusterType.ON_DEMAND
            logger.debug(f"Critical time pressure (2D): task+2D={total_task_remaining_with_2D/3600:.1f}h >= remaining={remaining_time/3600:.1f}h")
        
        if total_task_remaining >= remaining_time:
            if current_cluster_type == ClusterType.SPOT and self.remaining_restart_overhead < 1e-3:
                # Already on SPOT with no restart overhead, keep it
                request_type = ClusterType.SPOT
                logger.debug("Very tight deadline but SPOT running with no overhead, keeping SPOT")
            else:
                request_type = ClusterType.ON_DEMAND
                logger.debug(f"Tight deadline: task+D={total_task_remaining/3600:.1f}h >= remaining={remaining_time/3600:.1f}h")
            
            if self.restart_overhead == 0 and has_spot:
                # No restart overhead, SPOT is safe even at deadline
                request_type = ClusterType.SPOT
                logger.debug("No restart overhead, SPOT is safe")
        
        logger.debug(f"Decision: {current_cluster_type.name} -> {request_type.name}")
        return request_type
    
    def _uniform_progress_condition(self) -> float:
        """Uniform progress condition similar to RC/CR _condition()."""
        c_0 = self.task_duration
        c_t = self.task_duration - sum(self.task_done_time)
        t = self.env.elapsed_seconds
        r_0 = self.deadline
        return c_0 - c_t - t * c_0 / r_0
    
    def _sticky_condition(self) -> float:
        """Condition for staying on ON_DEMAND, similar to RC/CR _condition2()."""
        d = self.restart_overhead
        t = self.env.elapsed_seconds
        c_t = self.task_duration - sum(self.task_done_time)
        c_0 = self.task_duration
        r_0 = self.deadline
        return (t + 2 * d) * c_0 / r_0 - (c_0 - c_t)
    
    def _get_expected_value(self, region_id: int) -> float:
        """Get expected value for a region from hardcoded data."""
        # Map region_id to characteristics (assuming standard 5-region setup)
        region_names = ['us-east-1a_v100_1', 'us-east-1d_v100_1', 'us-east-1c_v100_1', 
                       'us-east-1f_v100_1', 'us-east-2a_v100_1']
        
        if region_id < len(region_names):
            region_name = region_names[region_id]
            if region_name in REGION_CHARACTERISTICS:
                return REGION_CHARACTERISTICS[region_name]['expected_value']
        
        # Fallback
        return 1.0
    
    @classmethod
    def _from_args(cls, parser):
        return cls(parser.parse_args())


# Register strategy
def get_strategy_class():
    return AvailabilityAwareExpectedValueStrategy